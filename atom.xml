<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>梦遥奇缘</title>
  <subtitle>想要，所以才去追寻--禾子</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://idiot6.com/"/>
  <updated>2021-01-01T05:47:17.499Z</updated>
  <id>http://idiot6.com/</id>
  
  <author>
    <name>梦遥奇缘</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>什么是播客</title>
    <link href="http://idiot6.com/2021/01/01/podcasts/"/>
    <id>http://idiot6.com/2021/01/01/podcasts/</id>
    <published>2021-01-01T05:00:00.000Z</published>
    <updated>2021-01-01T05:47:17.499Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是播客"><a href="#什么是播客" class="headerlink" title="什么是播客"></a>什么是播客</h3><ul>
<li><p>狭义的播客，一般是指独立播客。 即符合上述国外制作流程的播客。用去中心化的方式进行分发，所有内容都可以由你自己掌控。因此你需要有自己的托管服务器、有自己的域名、且 RSS 订阅链接中含有此域名，这样就算你托管的服务器挂掉了，听众还是可以通过这个固定的 RSS 链接找到你。</p>
</li>
<li><p>播客是一种数字媒体，指一系列的音频、视频、电子电台或文字档以列表形式经互联网发布，然后听众经由电子设备订阅该列表以下载或流当中的电子文件，从而接收内容。英语 “Podcast” 一词是 “iPod” 和 “broadcast”（广播）的混成词。</p>
</li>
<li>Podcast简单来说就是声音的节目，内容通常为原创的音讯或视讯录制节目，但也可以是电视或广播节目、演讲、表演或其他各种事件的录影播送，它是完全免费、并且来自世界各地的内容创作。</li>
<li>在2005年，苹果CEO乔布斯说：“Podcasting是下一代广播，用户现在可以订阅3,000多个免费Podcast，并且每个新的情节都可以通过互联网自动传送到他们的计算机和iPod。”，2020年iTunes商店现在有超过百万个单集播客可供选择，而全球已经有超过75万的独立播客存在，同时传播的渠道已经不仅仅是计算机、iPod，更多的以手机、智能手表、智能音箱（Alexa、HomePod）、CarPlay、RSS订阅等形式传播。</li>
</ul>
<p><strong>Polkacast :  A decentralization  podcast hosting platform</strong></p>
<h3 id="Polkacast是什么"><a href="#Polkacast是什么" class="headerlink" title="Polkacast是什么"></a>Polkacast是什么</h3><ul>
<li>Polkacast是基于Substrate、IPFS和以太坊智能合约等概念进行整合并创造出的BaaS，BaaS是区块链即服务，Polkacast平台旨在为创作者提供方便、快捷、简单可盈利的播客托管平台，同时实现社区高度自治，并且赋能TOKEN经济，能够帮助播客创作者创造二次收益，在除去广告之外还能获取平台TOKEN、铸造权等能力，Polkacast平台的BaaS特性是基于社区治理的、可扩展的、去中心化的、智能合约模式的NATIVE WASM应用，它将是每一个独立播客制作者和用户都喜欢的创作平台、分发平台。</li>
</ul>
<h3 id="播客增长渠道"><a href="#播客增长渠道" class="headerlink" title="播客增长渠道"></a>播客增长渠道</h3><ul>
<li>智能音箱的不断普及助推有声读物和播客实现发展。2020年，智能音箱在美国和中国城市地区的市场渗透率有望超过25%，36而随着全球其他地区逐步追上，预计将实现更高增长率。这些设备深受有声读物和播客听众欢迎，66%的美国智能音箱拥有者表示，他们至少每周使用智能音箱收听一本有声读物或播客节目。</li>
<li>无线耳机：美国年轻人基本上人手一个，让行动音频变得很便捷，2019年全球TWS无线耳机销售已达1.1亿件，预计到2020年，全球TWS无线耳机销量将达1.4亿件,预计2026年可以增长到1182亿元，年复合增长率(CAGR)为10.6%。</li>
<li>车联网：Podcast基本上有10%的用户，其实是每天是在车里消费的，它是通过CarPlay和Android Auto 来消费。</li>
</ul>
<h3 id="传统播客托管平台-VS-PolkaCast"><a href="#传统播客托管平台-VS-PolkaCast" class="headerlink" title="传统播客托管平台 VS PolkaCast"></a>传统播客托管平台 VS PolkaCast</h3><p><img src="https://cdn.bsatoshi.com/2020/12/13/podcast.png" alt="PolkaCast"></p>
<h3 id="Polkacast的特性："><a href="#Polkacast的特性：" class="headerlink" title="Polkacast的特性："></a>Polkacast的特性：</h3><ul>
<li>基于Polkadot的共享安全模型，有效确保高弹性和无分叉可升级性、可扩展、可跨链，链上治理高度统一；</li>
<li>基于以太坊的智能合约公平分配TOKEN和DAO社区治理，每一个Podcaster都有投票权和治理权；</li>
<li>基于IPFS存储，构建可靠的Baas内容托管平台；</li>
<li>永久免费、可盈利的播客创作者托管服务平台；</li>
<li>收听用户无需登陆、无社交的泛用型播客客户端，谨记用户隐私为第一要素；</li>
<li>播客创作内容全平台自动分发，包括但不限于Apple播客，Spotify，Stitcher，TuneIn，iHeartRadio，Google播客等第三方播客平台；</li>
</ul>
<h3 id="Polkacast的愿景"><a href="#Polkacast的愿景" class="headerlink" title="Polkacast的愿景"></a>Polkacast的愿景</h3><ul>
<li>Polkacast的目标是成为Polkadot网络的平行链，并从蓬勃发展的跨链生态系统和共享安全中受益，为播客创作者和用户提供更好的、更安全的社区自治服务，打造出保护隐私并创造收益的去中心化播客平台。</li>
<li>播客存在的意义是每个人都可以表达自己的观点，可以无拘无束的表达自我、展示自我，播客的独立性是播客最有魅力的地方，个人播客在表达自己的观点，企业播客在输出企业的价值观，我们深信每个人或企业都能以自身特色与独到风格开创属于自身的独立播客和品牌，而成功与否全交由社区成员定夺。</li>
</ul>
<h3 id="Polkacast-生态"><a href="#Polkacast-生态" class="headerlink" title="Polkacast 生态"></a>Polkacast 生态</h3><ul>
<li>DAPP版泛用型播客客户端</li>
<li>基于Polkacast的Baas服务</li>
<li>podcastser 铸造货币权</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Polkacast是一个纯粹的去中心化播客托管平台，相信在播客蓬勃发展的后期，一定会有更多的播客制作者需要去中心化的播客托管平台，而相对的也需要为区块链赋能TOKEN经济，为每一个用爱发电制作播客的播客者创造一点微薄的收益和变现渠道。</li>
</ul>
<h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><ul>
<li>如果您也对播客感兴趣，欢迎加入TG群，一起创造更好的播客生态，点击加入：<a href="https://t.me/zpodcasts" target="_blank" rel="external">Polkacast</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是播客&quot;&gt;&lt;a href=&quot;#什么是播客&quot; class=&quot;headerlink&quot; title=&quot;什么是播客&quot;&gt;&lt;/a&gt;什么是播客&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;狭义的播客，一般是指独立播客。 即符合上述国外制作流程的播客。用去中心化的方式进行分发，所有内容都
    
    </summary>
    
      <category term="podcasts" scheme="http://idiot6.com/categories/podcasts/"/>
    
    
      <category term="podcasts" scheme="http://idiot6.com/tags/podcasts/"/>
    
  </entry>
  
  <entry>
    <title>我的2020年</title>
    <link href="http://idiot6.com/2021/01/01/2020end/"/>
    <id>http://idiot6.com/2021/01/01/2020end/</id>
    <published>2021-01-01T02:00:00.000Z</published>
    <updated>2021-01-01T05:47:17.499Z</updated>
    
    <content type="html"><![CDATA[<p>2020,庆幸自己还活着…</p>
<p>从疫情开始到现在的未结束，整个人在2020年仿佛经历了生死轮回，每个人的经历不一样、认知不一样，自然就导致了结果不一样，在2月份从家出门到工作的城市，就在家封闭了3个月，每天过着焦虑的日子，仿佛自己随时都会死去，而自己追求的、热爱的、所爱的，仿佛一切都没有了，所以在疫情稍微好一点之后就常回家看看，有什么比父母更重要的呢，经济学上说：“分配决定了收益”，而现在的分配导致以后的结果，时间就那么多，总要流失，重要的是这些时间都用来干什么。</p>
<p>今年运动稍微有点懒散，没有减肥到预期的体重65KG，学会爱自己、爱生活，让自己过的开心，一个健康的生命比任何都重要。</p>
<h3 id="关于工作："><a href="#关于工作：" class="headerlink" title="关于工作："></a>关于工作：</h3><ul>
<li>WORK：<ol>
<li>从创业到失败，从后端到前端，心里路程一直在变，慢慢的理解商业模式、市场同样重要，技术只是解决方案，想盈利还是需要好的商业模式。</li>
<li>由于专职写前端，所以买了很多CSS、JS、HTTP等前端技术的书，争取在2021让自己的基础更稳。</li>
</ol>
</li>
</ul>
<h3 id="关于读书："><a href="#关于读书：" class="headerlink" title="关于读书："></a>关于读书：</h3><ul>
<li>READ：<ol>
<li>读了很多经济学的书，从头开始学金融，然后就发现生活中很多事情都会涉及到经济学基础，只是之前的自己没有注意到，而看了这些原理，才会更好的理解商业模式、好的生意，什么是企业的护城河等等。</li>
</ol>
</li>
</ul>
<h3 id="关于生活："><a href="#关于生活：" class="headerlink" title="关于生活："></a>关于生活：</h3><ul>
<li>LIFE：<ol>
<li>买了Ipad Pro ，用来记录金融相关的笔记和读书的笔记；</li>
<li>买了Apple Watch 5 ，跑步再也不用带着笨重的手机了，2021目标500公里；</li>
</ol>
</li>
</ul>
<h3 id="关于社交："><a href="#关于社交：" class="headerlink" title="关于社交："></a>关于社交：</h3><ul>
<li>CHAT：<ol>
<li>炒币认识的朋友不知不觉都4年了，而我们依然还是个韭菜，或许延迟满足感并不适合每个人。</li>
</ol>
</li>
</ul>
<h3 id="关于2021："><a href="#关于2021：" class="headerlink" title="关于2021："></a>关于2021：</h3><ul>
<li>FATURE：<ol>
<li>学好前沿的前端基础技术和算法；</li>
<li>下半年考雅思；</li>
<li>写一个开源的播客系统和DAPP；</li>
</ol>
</li>
</ul>
<p>— 这个社会的前进，需要我们每个人去担当，去负重前行。如果天空是黑暗的，那就摸黑生存。如果发出声音是危险的，那就保持沉默。如果自觉无力发光，那就蜷伏于墙角。但千万不要为精致的苟且而得意，更不要嘲讽那些比自己更勇敢热情推动社会前行的人们。—</p>
<blockquote>
<p>By：kk德米安 2020-01-01</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020,庆幸自己还活着…&lt;/p&gt;
&lt;p&gt;从疫情开始到现在的未结束，整个人在2020年仿佛经历了生死轮回，每个人的经历不一样、认知不一样，自然就导致了结果不一样，在2月份从家出门到工作的城市，就在家封闭了3个月，每天过着焦虑的日子，仿佛自己随时都会死去，而自己追求的、热爱的
    
    </summary>
    
      <category term="心の栄養" scheme="http://idiot6.com/categories/%E5%BF%83%E3%81%AE%E6%A0%84%E9%A4%8A/"/>
    
    
      <category term="点滴记录" scheme="http://idiot6.com/tags/%E7%82%B9%E6%BB%B4%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>H5如何实时在手机上调试页面并抓包</title>
    <link href="http://idiot6.com/2020/08/14/syp_debugger/"/>
    <id>http://idiot6.com/2020/08/14/syp_debugger/</id>
    <published>2020-08-14T09:28:53.000Z</published>
    <updated>2021-01-01T02:25:04.904Z</updated>
    
    <content type="html"><![CDATA[<h3 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h3><ul>
<li>使用safari自带调试，需连接数据线，chrome同理，更多详情请查看：<a href="https://juejin.im/post/6844903977557950471" target="_blank" rel="external">Safari和Chrome浏览器真机调试</a></li>
<li>方式二，使用spy-debugger调试</li>
</ul>
<h3 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h3><p><a href="https://github.com/wuchangming/spy-debugger" target="_blank" rel="external">spy-debugger</a> 用来调试安卓、IOS 、webview 等 H5页面适配问题，抓包的话主要用在webview，调试页面适配spy-debugger还是很方便的，不需要连接数据线，直接可以访问多人同时调试。</p>
<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><ul>
<li><p>安装：</p>
<ul>
<li>win 下=》 <code>npm install spy-debugger -g</code></li>
<li>macOS 下=〉 <code>sudo npm install spy-debugger -g</code></li>
</ul>
</li>
<li><p>启动</p>
<ul>
<li>命令行输入：<code>spy-debugger</code></li>
<li><img src="https://i.loli.net/2020/08/10/bZujnayV2oNHwmM.png" alt="启动spy debugger"></li>
</ul>
</li>
<li><p>上手调试必备条件</p>
<ul>
<li>手机和电脑在同一wifi下</li>
<li>命令行输入：<code>spy-debugger</code> win或macOS下如果启动不了命令，请关闭防火墙后重试</li>
<li>设置当前手机http代理，如上图打开的端口，默认是9888，然后是自己当前本机的ip地址<ul>
<li>Android设置代理步骤：设置 - WLAN - 长按选中网络 - 修改网络 - 高级 - 代理设置 - 手动</li>
<li>iOS设置代理步骤：设置 - 无线局域网 - 选中网络 - HTTP代理手动</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ios需要单独安装证书"><a href="#ios需要单独安装证书" class="headerlink" title="ios需要单独安装证书"></a>ios需要单独安装证书</h3><ul>
<li>Safari访问地址 <a href="http://spydebugger.com/cert" target="_blank" rel="external">cert 安装</a> ，允许，安装，输入密码，完成即可</li>
</ul>
<h3 id="如何访问"><a href="#如何访问" class="headerlink" title="如何访问"></a>如何访问</h3><ul>
<li>设置好端口后，手机浏览器输入<code>spy-debugger</code>启动时的ip和本地启动项目的端口</li>
<li>比如：当前启动的ip是：192.168.2.36，本地启动的项目访问地址是：<code>http://localhost:8080</code>，即得出调试地址为：<code>http://192.168.2.36:8080</code></li>
</ul>
<h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><p><img src="https://i.loli.net/2020/08/10/8hOx7LX2GA4TBlH.png" alt="spy-debugger抓包"></p>
<p>如上图所示，当前的method，host，即为调试起发起的请求，点击对应的请求可以看到Response返回内容</p>
<h3 id="自定义设置端口、代理"><a href="#自定义设置端口、代理" class="headerlink" title="自定义设置端口、代理"></a>自定义设置端口、代理</h3><ul>
<li>启动指定端口：spy-debugger -p 8888</li>
<li>设置代理：spy-debugger -e <a href="http://127.0.0.1:7980" target="_blank" rel="external">http://127.0.0.1:7980</a></li>
<li>更多自定义配置请查看<a href="https://github.com/wuchangming/spy-debugger" target="_blank" rel="external">文档说明</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;调试方法&quot;&gt;&lt;a href=&quot;#调试方法&quot; class=&quot;headerlink&quot; title=&quot;调试方法&quot;&gt;&lt;/a&gt;调试方法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;使用safari自带调试，需连接数据线，chrome同理，更多详情请查看：&lt;a href=&quot;https://ju
    
    </summary>
    
      <category term="javascript" scheme="http://idiot6.com/categories/javascript/"/>
    
    
      <category term="chrome - cookie - spyDebugger - webview" scheme="http://idiot6.com/tags/chrome-cookie-spyDebugger-webview/"/>
    
  </entry>
  
  <entry>
    <title>ES6 语法学习之let、var、const</title>
    <link href="http://idiot6.com/2020/08/04/es6-let-const/"/>
    <id>http://idiot6.com/2020/08/04/es6-let-const/</id>
    <published>2020-08-04T10:28:53.000Z</published>
    <updated>2020-08-05T13:25:45.242Z</updated>
    
    <content type="html"><![CDATA[<h3 id="let-、var-、-const"><a href="#let-、var-、-const" class="headerlink" title="let 、var 、 const"></a>let 、var 、 const</h3><ul>
<li>var、let、const的区别:<ol>
<li>使用方法</li>
<li>块级作用域</li>
<li>不存在变量提升</li>
<li>暂时性死区</li>
<li>不可重复声明变量</li>
<li>let、const声明的全局变量不会挂在顶层对象下面</li>
</ol>
</li>
</ul>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul>
<li>let已经完全可以取代var，定义变量</li>
<li>const一般用来定义：常量、声明匿名函数、箭头函数等</li>
<li>开发时基本默认使用 const，只有当确实需要改变变量的值的时候才使用 let（比如定义一个组件或map遍历时使用const定义后在调用，使代码更结构化、可读性变高）</li>
</ul>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><ul>
<li><p>块级声明用于声明在指定块的作用域之外无法访问的变量。let 和 const 都是块级声明的一种。</p>
</li>
<li><p>ECMAScript 6 引入了块级作用域，块级作用域存在于：函数内部和当前块中(字符 { 和 } 之间的区域 =》if(){ xxxxxx 此处也是块级 })</p>
</li>
<li>块级作用域可以无限嵌套</li>
<li>块级作用域的真正作用是使代码分割成块（eg：3）</li>
<li>块级作用域声明函数，最好使用匿名函数的形式。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;&#123;&#123;&#123;</div><div class="line">  &#123;let test = &apos;Hello World&apos;&#125;</div><div class="line">  console.log(test); // 报错  拿不到子作用域的变量</div><div class="line">&#125;&#125;&#125;&#125;;</div><div class="line"></div><div class="line">Eg3：for (let i = 0; i &lt; 3; i++) &#123;</div><div class="line">  let i = &apos;abc&apos;;</div><div class="line">  console.log(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此处的let是一个单独的作用域，因此结果是  abc 输出了三次，每次迭代循环时都创建一个新变量，并以之前迭代中同名变量的值将其初始化，此时的let作用类似于闭包。</p>
<h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><p>变量提升的现象：在同一作用域下，变量可以在声明之前使用，值为 undefined，（ES5时 var 会出现变量提升，ES6 使用直接console一个未声明的值会报错Uncaught ReferenceError: xxxxxx is not defined）</p>
<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><ul>
<li>只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</li>
<li><p>暂时性死区和不能变量提升的意义：为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。</p>
<h3 id="不允许重复声明变量"><a href="#不允许重复声明变量" class="headerlink" title="不允许重复声明变量"></a>不允许重复声明变量</h3></li>
<li><p>let、const不允许在相同作用域内，重复声明同一个变量</p>
</li>
</ul>
<h3 id="let、const声明的全局变量不会挂在顶层对象下面"><a href="#let、const声明的全局变量不会挂在顶层对象下面" class="headerlink" title="let、const声明的全局变量不会挂在顶层对象下面"></a>let、const声明的全局变量不会挂在顶层对象下面</h3><ul>
<li>浏览器环境顶层对象是: window</li>
<li>node环境顶层对象是: global</li>
</ul>
<ul>
<li>var声明的全局变量（会创建一个新的全局变量作为全局对象的属性）会挂在顶层对象下面，而let、const不会挂在顶层对象下面。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var value = 535;</div><div class="line">console.log(window.value); // 535</div><div class="line"></div><div class="line">let value = 535;</div><div class="line">console.log(window.value); // undefined</div></pre></td></tr></table></figure>
<ul>
<li>const 一旦声明，必须马上赋值,并且给了值之后就不能改变（变量指向的那个内存地址所保存的数据不得改动）<ul>
<li>简单类型(number、string、boolean)：内存地址就是值,即常量(一变就报错).</li>
<li>复杂类型(obj、arr等)：地址保存的是一个指针，const只能保证指针是固定的(总是指向同一个地址),它内部的值是可以改变的<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li>
</ul>
</li>
<li>let可以先声明稍后再赋值,而const在 声明之后必须马上赋值，否则会报错</li>
<li>const 简单类型一旦声明就不能再更改，复杂类型(数组、对象等)指针指向的地址不能更改，内部数据可以更改。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;let-、var-、-const&quot;&gt;&lt;a href=&quot;#let-、var-、-const&quot; class=&quot;headerlink&quot; title=&quot;let 、var 、 const&quot;&gt;&lt;/a&gt;let 、var 、 const&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;var、let、
    
    </summary>
    
      <category term="javascript" scheme="http://idiot6.com/categories/javascript/"/>
    
    
      <category term="chrome - cookie - React native - HTTPOnly" scheme="http://idiot6.com/tags/chrome-cookie-React-native-HTTPOnly/"/>
    
  </entry>
  
  <entry>
    <title>ES6 语法学习 模版字符串</title>
    <link href="http://idiot6.com/2020/08/04/es6-common-tag/"/>
    <id>http://idiot6.com/2020/08/04/es6-common-tag/</id>
    <published>2020-08-04T10:28:53.000Z</published>
    <updated>2020-08-05T13:25:45.242Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模版字符串概念和用途"><a href="#模版字符串概念和用途" class="headerlink" title="模版字符串概念和用途"></a>模版字符串概念和用途</h3><ul>
<li>模板字符串使用反引号 (<code> </code>) 来代替普通字符串中的用双引号和单引号。</li>
<li>模板字符串可以包含特定语法（${expression}）的占位符。占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数来对模板字符串进行操作处理。</li>
<li>在模版字符串内使用反引号（`）时，需要在它前面加转义符（\）。</li>
</ul>
<p>简单的说模版字符串就是用来处理一些特殊的字符、数据展示、react模版时用来占位的一种特殊写法，以一种更优雅的方式来表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 旧方式</div><div class="line">var a = 5;</div><div class="line">var b = 10;</div><div class="line">console.log(&apos;Fifteen is &apos; + (a + b) + &apos; and\nnot &apos; + (2 * a + b) + &apos;.&apos;);</div><div class="line"></div><div class="line">// 新方式</div><div class="line"></div><div class="line">var a = 5;</div><div class="line">var b = 10;</div><div class="line">console.log(`Fifteen is $&#123;a + b&#125; and</div><div class="line">not $&#123;2 * a + b&#125;.`);</div><div class="line"></div><div class="line">// 最终结果</div><div class="line">// &quot;Fifteen is 15 and</div><div class="line">// not 20.&quot;</div></pre></td></tr></table></figure>
<h3 id="语法形式"><a href="#语法形式" class="headerlink" title="语法形式"></a>语法形式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 单行字符串</div><div class="line">`string text` </div><div class="line"></div><div class="line">// 多行字符串 方便换行</div><div class="line">`string text line 1</div><div class="line"> string text line 2`</div><div class="line"></div><div class="line">// 嵌套模板</div><div class="line">`string text $&#123;expression&#125; string text`</div><div class="line"></div><div class="line">// 根据不同的状态展示不同的class</div><div class="line">const classes = `header $&#123; isLargeScreen() ? &apos;&apos; :</div><div class="line"> `icon-$&#123;item.isCollapsed ? &apos;expander&apos; : &apos;collapser&apos;&#125;` &#125;`;</div><div class="line"></div><div class="line">// 自定义的标签函数处理模板字符串</div><div class="line">tag `string text $&#123;expression&#125; string text`</div></pre></td></tr></table></figure>
<h3 id="如何解决繁琐的正则"><a href="#如何解决繁琐的正则" class="headerlink" title="如何解决繁琐的正则"></a>如何解决繁琐的正则</h3><ul>
<li>直接使用<a href="https://github.com/zspecza/common-tags" target="_blank" rel="external">common-tags库</a>，解决一些基础的去除空格，数据处理问题，更多使用方式请查看文档</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;模版字符串概念和用途&quot;&gt;&lt;a href=&quot;#模版字符串概念和用途&quot; class=&quot;headerlink&quot; title=&quot;模版字符串概念和用途&quot;&gt;&lt;/a&gt;模版字符串概念和用途&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;模板字符串使用反引号 (&lt;code&gt; &lt;/code&gt;) 来代替普
    
    </summary>
    
      <category term="javascript" scheme="http://idiot6.com/categories/javascript/"/>
    
    
      <category term="chrome - cookie - React native - HTTPOnly" scheme="http://idiot6.com/tags/chrome-cookie-React-native-HTTPOnly/"/>
    
  </entry>
  
  <entry>
    <title>Chrome 80版本之后为何使用SameSite，cookie隐私和防止CSRF问题如何解决</title>
    <link href="http://idiot6.com/2020/08/04/chrome-samesite/"/>
    <id>http://idiot6.com/2020/08/04/chrome-samesite/</id>
    <published>2020-08-04T03:59:53.000Z</published>
    <updated>2020-08-05T13:25:45.242Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么添加SameSite"><a href="#为什么添加SameSite" class="headerlink" title="为什么添加SameSite"></a>为什么添加SameSite</h3><ul>
<li>cookies面临的两个问题：用户隐私 / CSRF(跨站请求伪造)</li>
<li>明确cookie的使用范围，减少被攻击的可能</li>
</ul>
<h3 id="Cookie-的设置步骤"><a href="#Cookie-的设置步骤" class="headerlink" title="Cookie 的设置步骤"></a>Cookie 的设置步骤</h3><ul>
<li>客户端发送 HTTP 请求到服务器</li>
<li>当服务器收到 HTTP 请求时，在响应头里面添加一个 Set-Cookie 字段</li>
<li>浏览器收到响应后保存下 Cookie</li>
<li>之后对该服务器每一次请求中都通过 Cookie 字段将 Cookie 信息发送给服务器。</li>
</ul>
<h3 id="cookie的一些属性"><a href="#cookie的一些属性" class="headerlink" title="cookie的一些属性"></a>cookie的一些属性</h3><p><img src="https://i.loli.net/2020/08/03/25vlgEdmMktCwGy.png" alt="浏览器cookie和same-site"></p>
<ul>
<li><p>Name/Value</p>
<ul>
<li>用 JavaScript 操作 Cookie 的时候注意对 Value 进行编码处理。</li>
</ul>
</li>
<li><p>Expires</p>
<ul>
<li><p>Expires 用于设置 Cookie 的过期时间。比如：</p>
</li>
<li><p>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</p>
</li>
<li><p>当 Expires 属性缺省时，表示是会话性 Cookie，像上图 Expires 的值为 Session，表示的就是会话性 Cookie。当为会话性 Cookie 的时候，值保存在客户端内存中，并在用户关闭浏览器时失效。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期 Cookie 也会被保留下来，就好像浏览器从来没有关闭一样。</p>
</li>
<li><p>与会话性 Cookie 相对的是持久性 Cookie，持久性 Cookies 会保存在用户的硬盘中，直至过期或者清除 Cookie。这里值得注意的是，设定的日期和时间只与客户端相关，而不是服务端。</p>
</li>
</ul>
</li>
<li><p>Max-Age</p>
<pre><code>- Max-Age 用于设置在 Cookie 失效之前需要经过的秒数。比如：
- Set-Cookie: id=a3fWa; Max-Age=604800;
- Max-Age 可以为正数、负数、甚至是 0。
- 如果 max-Age 属性为正数时，浏览器会将其持久化，即写到对应的 Cookie 文件中。
- 当 max-Age 属性为负数，则表示该 Cookie 只是一个会话性 Cookie。
- 当 max-Age 为 0 时，则会立即删除这个 Cookie。
- 假如 Expires 和 Max-Age 都存在，Max-Age 优先级更高。
</code></pre></li>
<li><p>Domain</p>
<ul>
<li>Domain 指定了 Cookie 可以送达的host。假如没有指定，那么默认值为当前文档访问地址中的主机部分（但是不包含子域名）。</li>
<li>不能跨域设置 Cookie</li>
</ul>
</li>
<li><p>Path</p>
<ul>
<li><p>Path 指定了一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部。比如设置 Path=/docs，/docs/Web/ 下的资源会带 Cookie 首部，/test 则不会携带 Cookie 首部。</p>
</li>
<li><p>Domain 和 Path 标识共同定义了 Cookie 的作用域：即 Cookie 应该发送给哪些 URL。</p>
</li>
</ul>
</li>
<li><p>Secure属性</p>
<ul>
<li>标记为 Secure 的 Cookie 只应通过被HTTPS协议加密过的请求发送给服务端。使用 HTTPS 安全协议，可以保护 Cookie 在浏览器和 Web 服务器间的传输过程中不被窃取和篡改。</li>
</ul>
</li>
<li><p>HTTPOnly</p>
<ul>
<li>设置 HTTPOnly 属性可以防止客户端脚本通过 document.cookie 等方式访问 Cookie，有助于避免 XSS 攻击。</li>
</ul>
</li>
<li><p>SameSite</p>
<ul>
<li>SameSite 是谷歌 2 月份发布的 Chrome80 版本中默认屏蔽了第三方的 Cookie，更大程度的防止跨域之间CSRF和保护用户隐私，借用Token+SameSite形式有效的解决CSRF问题。</li>
</ul>
</li>
</ul>
<h3 id="SameSite属性值"><a href="#SameSite属性值" class="headerlink" title="SameSite属性值"></a>SameSite属性值</h3><ul>
<li><p>SameSite属性用来限制第三方 Cookie，减少安全风险，有三个值：</p>
<ul>
<li>Strict：仅允许一方请求携带 Cookie，即浏览器将只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致</li>
<li>Lax：允许部分第三方请求携带 Cookie</li>
<li>None：无论是否跨站都会发送 Cookie</li>
</ul>
</li>
<li><p>Strict</p>
<ul>
<li>Strict最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。</li>
<li>Set-Cookie: CookieName=CookieValue; SameSite=Strict;</li>
</ul>
</li>
<li><p>Lax</p>
<ul>
<li>Lax规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。</li>
<li>Set-Cookie: CookieName=CookieValue; SameSite=Lax;</li>
</ul>
</li>
<li><p>None</p>
<ul>
<li>Chrome 计划将Lax变为默认设置(80版本已实施)。这时，网站可以选择显式关闭SameSite属性，将其设为None。不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效。</li>
<li>Set-Cookie: widget_session=abc123; SameSite=None; Secure</li>
</ul>
</li>
</ul>
<h3 id="SameSite影响"><a href="#SameSite影响" class="headerlink" title="SameSite影响"></a>SameSite影响</h3><p><img src="https://i.loli.net/2020/08/03/xtH5pQylGW84bj3.png" alt="samesite.png"></p>
<ul>
<li><p>从上图可以看出，对大部分 web 应用而言，Post 表单，iframe，AJAX，Image 这四种情况从以前的跨站会发送三方 Cookie，变成了不发送。</p>
</li>
<li><p>Post表单：应该的，学 CSRF 总会举表单的例子。</p>
</li>
<li><p>iframe：iframe 嵌入的 web 应用有很多是跨站的，都会受到影响。</p>
</li>
<li><p>AJAX：可能会影响部分前端取值的行为和结果。</p>
</li>
<li><p>Image：图片一般放 CDN，大部分情况不需要 Cookie，故影响有限。但如果引用了需要鉴权的图片，可能会受到影响。</p>
</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li><p>临时方案可设置 SameSite 为 None，必须同时设置Secure属性 （Set-cookie: key=value; SameSite=None; Secure）</p>
</li>
<li><p>合理的解决方案简单总结应该是按照谷歌浏览器规则:</p>
<ul>
<li>默认设置 SameSite=Lax ，需要第三方cookie的则设置为none，CSRF Token会话类Cookies设置Strict（添加SameSite就是为了防止CSRF攻击）</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2020/08/03/TwNmZu9JD78SxWX.png" alt="netflix默认设置SameSite值为Lax"></p>
<ul>
<li>Notice：HTTP 接口不支持 SameSite=none，UA 检测，部分浏览器不能加 SameSite=none</li>
<li><a href="https://www.chromium.org/updates/same-site/incompatible-clients" target="_blank" rel="external">浏览器识别UA能否添加SameSite</a></li>
</ul>
<h3 id="新版本的chrome浏览器（80版本之后），7月14后灰度测试，7月28基本覆盖大部分chrome用户"><a href="#新版本的chrome浏览器（80版本之后），7月14后灰度测试，7月28基本覆盖大部分chrome用户" class="headerlink" title="新版本的chrome浏览器（80版本之后），7月14后灰度测试，7月28基本覆盖大部分chrome用户"></a>新版本的chrome浏览器（80版本之后），7月14后灰度测试，7月28基本覆盖大部分chrome用户</h3><ul>
<li><p>7月14日稳定发布Chrome 84的同时恢复SameSite Cookie的强制实施，同时对Chrome 80+启用强制实施。</p>
</li>
<li><p>cookie的校验更加严格，SameSite属性默认值由None变为Lax</p>
<h3 id="same-site版本更新说明和讨论"><a href="#same-site版本更新说明和讨论" class="headerlink" title="same-site版本更新说明和讨论"></a>same-site版本更新说明和讨论</h3></li>
<li><p><a href="https://www.chromium.org/updates/same-site" target="_blank" rel="external">SameSite Updates Version</a></p>
</li>
<li><a href="https://github.com/google/google-api-javascript-client/issues/561" target="_blank" rel="external">New cross-site cookie not ‘SameSite’ warning </a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/157" target="_blank" rel="external">浏览器系列之 Cookie 和 SameSite 属性</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html" target="_blank" rel="external">阮一峰：Cookie 的 SameSite 属性</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么添加SameSite&quot;&gt;&lt;a href=&quot;#为什么添加SameSite&quot; class=&quot;headerlink&quot; title=&quot;为什么添加SameSite&quot;&gt;&lt;/a&gt;为什么添加SameSite&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;cookies面临的两个问题：用户隐私 
    
    </summary>
    
      <category term="javascript" scheme="http://idiot6.com/categories/javascript/"/>
    
    
      <category term="chrome - cookie - React native - HTTPOnly" scheme="http://idiot6.com/tags/chrome-cookie-React-native-HTTPOnly/"/>
    
  </entry>
  
  <entry>
    <title>SEO学习记录</title>
    <link href="http://idiot6.com/2020/07/25/SEO%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://idiot6.com/2020/07/25/SEO学习记录/</id>
    <published>2020-07-25T07:55:53.000Z</published>
    <updated>2020-07-25T08:02:59.614Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SEO优化学习记录"><a href="#SEO优化学习记录" class="headerlink" title="SEO优化学习记录"></a>SEO优化学习记录</h3><ul>
<li>页面布局</li>
<li>挖词工具</li>
<li>友链</li>
<li>内链</li>
<li>外链</li>
<li>伪原创</li>
<li>百度算法</li>
</ul>
<p><img src="https://cdn.bsatoshi.com/2020/07/25/SEO.png" alt="SEO优化学习记录"></p>
<h3 id="seo市场营销"><a href="#seo市场营销" class="headerlink" title="seo市场营销"></a>seo市场营销</h3><ul>
<li>营销布局</li>
<li>策略思维</li>
<li>上升排名</li>
</ul>
<p><img src="https://cdn.bsatoshi.com/2020/07/25/market.png" alt="seo市场营销"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;SEO优化学习记录&quot;&gt;&lt;a href=&quot;#SEO优化学习记录&quot; class=&quot;headerlink&quot; title=&quot;SEO优化学习记录&quot;&gt;&lt;/a&gt;SEO优化学习记录&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;页面布局&lt;/li&gt;
&lt;li&gt;挖词工具&lt;/li&gt;
&lt;li&gt;友链&lt;/li&gt;

    
    </summary>
    
      <category term="seo" scheme="http://idiot6.com/categories/seo/"/>
    
    
      <category term="seo" scheme="http://idiot6.com/tags/seo/"/>
    
      <category term="seo优化" scheme="http://idiot6.com/tags/seo%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>React native 遇到的bug记录和解决方式</title>
    <link href="http://idiot6.com/2020/07/24/React%20native%20%E9%81%87%E5%88%B0%E7%9A%84bug%E8%AE%B0%E5%BD%95%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/"/>
    <id>http://idiot6.com/2020/07/24/React native 遇到的bug记录和解决方式/</id>
    <published>2020-07-24T10:03:53.000Z</published>
    <updated>2020-07-25T08:02:59.614Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小米手机无法通过-adb-install-或sudo-npx-react-native-run-android-安装apk包"><a href="#小米手机无法通过-adb-install-或sudo-npx-react-native-run-android-安装apk包" class="headerlink" title="小米手机无法通过 adb install 或sudo npx react-native run-android 安装apk包"></a>小米手机无法通过 <code>adb install 或sudo npx react-native run-android</code> 安装apk包</h3><ul>
<li>首先确保自己开启了端口 <code>adb reverse tcp:8081 tcp:8081</code> ,然后运行<code>sudo npx react-native run-android</code> 然后出现错误： <code>Failure [INSTALL_FAILED_USER_RESTRICTED: Install canceled by user]</code></li>
<li>解决：小米（mi8青春版）手机安装测试包需要允许手机使用USB安装应用，只打开开发者和连接USB是没有用的，能用的功能是充电，因此需要在手机上设置-》更多设置-〉开发者选项-》打开USB安装；</li>
<li>然后在运行adb install 安装apk或者直接使用<code>sudo npx react-native run-android</code>安装</li>
</ul>
<h3 id="Oppo部分机型出现不能使用相机和存储功能"><a href="#Oppo部分机型出现不能使用相机和存储功能" class="headerlink" title="Oppo部分机型出现不能使用相机和存储功能"></a>Oppo部分机型出现不能使用相机和存储功能</h3><p><code>Android APIv29 FileNotFoundException EACCES (Permission denied)</code></p>
<p>修改application 配置：<code>android:requestLegacyExternalStorage=&quot;true&quot;</code></p>
<h3 id="IOS请求正常，安卓机小米、oppo部分机型不能使用axios请求，一直出现Network-error-Android"><a href="#IOS请求正常，安卓机小米、oppo部分机型不能使用axios请求，一直出现Network-error-Android" class="headerlink" title="IOS请求正常，安卓机小米、oppo部分机型不能使用axios请求，一直出现Network error  (Android)"></a>IOS请求正常，安卓机小米、oppo部分机型不能使用axios请求，一直出现Network error  (Android)</h3><ul>
<li>RN 版本：0.62.2</li>
<li>axios ：0.19.2</li>
<li>修改安卓下配置：<code>android &gt; gradle.properties</code> =&gt; <code>FLIPPER_VERSION=0.39.0</code></li>
</ul>
<h3 id="安卓部分机型出现打开debug不能点击屏幕"><a href="#安卓部分机型出现打开debug不能点击屏幕" class="headerlink" title="安卓部分机型出现打开debug不能点击屏幕"></a>安卓部分机型出现打开debug不能点击屏幕</h3><ul>
<li>打开debug时需要不能切换屏幕，并把当前debug在窗口最前面，使用终端调试即可（需要双屏幕，否则不能玩）</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;小米手机无法通过-adb-install-或sudo-npx-react-native-run-android-安装apk包&quot;&gt;&lt;a href=&quot;#小米手机无法通过-adb-install-或sudo-npx-react-native-run-android-安装
    
    </summary>
    
      <category term="react" scheme="http://idiot6.com/categories/react/"/>
    
    
      <category term="ios" scheme="http://idiot6.com/tags/ios/"/>
    
      <category term="dart" scheme="http://idiot6.com/tags/dart/"/>
    
      <category term="React native" scheme="http://idiot6.com/tags/React-native/"/>
    
      <category term="flutter" scheme="http://idiot6.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>2020最新React Native 0.62.2版本开发指南总结</title>
    <link href="http://idiot6.com/2020/07/24/2020%E6%9C%80%E6%96%B0React%20Native%200.62.2%E7%89%88%E6%9C%AC%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E6%80%BB%E7%BB%93/"/>
    <id>http://idiot6.com/2020/07/24/2020最新React Native 0.62.2版本开发指南总结/</id>
    <published>2020-07-24T09:22:53.000Z</published>
    <updated>2020-07-25T08:02:59.614Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一个新手需要哪些基础知识上手RN开发？"><a href="#一个新手需要哪些基础知识上手RN开发？" class="headerlink" title="一个新手需要哪些基础知识上手RN开发？"></a>一个新手需要哪些基础知识上手RN开发？</h3><ul>
<li>开发工具和插件等准备工作</li>
<li>Git基础</li>
<li>Javascript 基础</li>
<li>ES6 基础</li>
<li>CSS3 基础</li>
<li>Flex 布局</li>
<li>React 基础</li>
<li>Redux、Saga</li>
<li>React Native 基础</li>
<li>IOS开发者账号和Xcode使用基础</li>
<li>Android Studio使用和配置</li>
<li>API调试</li>
<li>翻墙工具</li>
<li>拓展学习</li>
</ul>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li><p>要想有一个效率的开发效果，必然需要一个效率的开发工具，因此开发工具和一些基础的插件已经成为开发者必备的工具，比如前端需要VSCode、WebStorm等，而后端则需要对应不同的语言使用不同的编辑器，比如Go用Goland、Java使用Idea、Php使用PhpStorm等。</p>
</li>
<li><p>这里只介绍前端开发的一些基础工具，比如VSCode插件、Google Chrome插件。</p>
</li>
<li><p>前端开发工具：</p>
<ul>
<li>VS Code</li>
<li>WebStorm</li>
</ul>
</li>
<li><p>由于作者使用的是VS Code，所以也推荐此工具，简洁方便，外加强大的插件功能，让开发效率可以更高，当然玩法也变的更多。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/07/24/KezFLDioVl7vBdW.png" alt="vscode 插件"></p>
<ul>
<li><p>VS Code 需要哪些主题和基础的插件</p>
<ul>
<li>One Dark Pro ，主题，根据自己喜欢选择即可</li>
<li>vscode-leetcode，刷题必备神器</li>
<li>Path Intellisense，自动补全路径，在也不用一直输入</li>
<li>Document this，js快速注释模版</li>
<li>Beautify ，代码格式化</li>
<li>React Native Tools，调试、提示</li>
<li>ESLint ，语法检查</li>
<li>vetur，vue语法高亮</li>
<li>Atuo Rename Tag 、Auto Close Tag，自动补全Tag标签，修改时同步，补全闭合标签</li>
<li>Git History，图形化查看git历史提交</li>
<li>JavaScript (ES6) code snippets，es6语法提示高亮</li>
<li>ES7 React/Redux/GraphQL/React-Native snippets，R系列开发必备</li>
</ul>
</li>
<li><p>谷歌Chrome 插件</p>
<ul>
<li>FeHelper，json格式化、网页取色、时间戳等常用工具</li>
<li>Adblock Plus、ublock，屏蔽广告必备</li>
<li>Momentum ,简洁的新标签页</li>
<li>React Developer Tools ， react调试工具</li>
<li>Vue.js devtools ，vue调试工具</li>
<li>Quick QR ， 二维码生成器</li>
<li>划词翻译</li>
<li>postman，调试接口必备</li>
<li>wappalyzer ， 查看网页使用的技术</li>
</ul>
</li>
</ul>
<h3 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h3><ul>
<li>git是什么？<ul>
<li>是一个分布式版本控制软件。</li>
</ul>
</li>
<li><a href="https://git-scm.com/book/zh/v2/" target="_blank" rel="external">git知识大全指南</a></li>
<li><a href="https://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="external">git基础指南</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="external">廖雪峰,Git教程</a></li>
<li><a href="https://backlog.com/git-tutorial/cn/intro/intro1_1.html" target="_blank" rel="external">猴子都能懂的Git基础，进阶</a></li>
</ul>
<h3 id="Javascript-基础"><a href="#Javascript-基础" class="headerlink" title="Javascript 基础"></a>Javascript 基础</h3><ul>
<li>推荐使用 MDN JS入门教程<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web/JavaScript_basics" target="_blank" rel="external">JavaScript基础</a></li>
</ul>
</li>
</ul>
<h3 id="ES6-基础"><a href="#ES6-基础" class="headerlink" title="ES6 基础"></a>ES6 基础</h3><ul>
<li><p>什么是ES6？</p>
<ul>
<li>ECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</li>
</ul>
</li>
<li><p>入门文档推荐</p>
<ul>
<li><a href="https://es6.ruanyifeng.com/" target="_blank" rel="external">阮一峰 ES6 入门教程</a></li>
<li><a href="http://caibaojian.com/es6/" target="_blank" rel="external">ES6 入门文档</a></li>
</ul>
</li>
</ul>
<h3 id="CSS3-基础"><a href="#CSS3-基础" class="headerlink" title="CSS3 基础"></a>CSS3 基础</h3><ul>
<li>Css做为页面的重要属性和Html，Js一样，建议先了解Css，然后在学习Css3如何布局、盒子模型、样式层叠等其他属性。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" target="_blank" rel="external">MDN Css 入门介绍</a></li>
<li><a href="https://segmentfault.com/a/1190000018585523" target="_blank" rel="external">CSS3开发文档</a></li>
<li><a href="http://css.cuishifeng.cn/" target="_blank" rel="external">Css/Css3样式参考手册</a></li>
</ul>
<h3 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h3><ul>
<li><p>什么是flex布局？</p>
<ul>
<li>Flexible Box 模型，通常被称为 flexbox，是一种一维的布局模型。它给 flexbox 的子元素之间提供了强大的空间分布和对齐能力。</li>
<li>使用Flex布局很大程度上是为了适配不同机型，甚至是这种形式的布局更有效率去开发项目，节省时间。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox" target="_blank" rel="external">MDN Flex布局基础知识</a></li>
</ul>
</li>
<li><p>flex布局教程指南</p>
<ul>
<li><a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="external">阮一峰 Flex 布局教程：语法篇</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="external">阮一峰 Flex 布局教程：实例篇</a></li>
</ul>
</li>
<li><p>Css3 Flexbox布局口诀</p>
<ul>
<li><a href="https://weibo.com/1712131295/CoRnElNkZ?ref=collection&amp;type=comment#_rnd1595575656531" target="_blank" rel="external">5张图看懂Flexbox布局</a></li>
</ul>
</li>
<li><p>延伸阅读</p>
<ul>
<li><a href="https://juejin.im/post/5e8ae27df265da47f144a8db" target="_blank" rel="external">深度解析 CSS Flexbox 布局</a></li>
</ul>
</li>
</ul>
<h3 id="React-、Redux-基础"><a href="#React-、Redux-基础" class="headerlink" title="React 、Redux 基础"></a>React 、Redux 基础</h3><ul>
<li><p>React 基础</p>
<ul>
<li>学习是一个循序渐进的过程，推荐先看官方的基础文档，并上手直接写代码，跟着demo走起来，看再多说在多，不如直接做，逼逼那么多根本没用，不是天才就努力实干。对于大多数语言而言，目前大多数官方教程足够让你学会基础，如果不能让新手上手（没有笨的学生，只有教不好的老师），那只能说这是一门失败的语言… </li>
<li><a href="https://zh-hans.reactjs.org/tutorial/tutorial.html" target="_blank" rel="external">官方文档入门学习React</a></li>
</ul>
</li>
<li><p>拓展使用第三方教程</p>
<ul>
<li>全栈公开课，Part 1 部分讲解React入门，当然也推荐从头开始，系统的学习Web开发，也可以直接学习React和Redux部分</li>
<li><a href="https://fullstackopen.com/zh#course-contents" target="_blank" rel="external">FullStack–React和Redux基础</a></li>
<li><a href="https://www.runoob.com/react/react-tutorial.html" target="_blank" rel="external">React 教程–菜鸟教程版</a></li>
<li><a href="https://shenbao.github.io/ishehui/html/React/React%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html" target="_blank" rel="external">快速入门React基础知识</a></li>
</ul>
</li>
<li><p>Redux、Store、Saga、Reducer基础</p>
<ul>
<li>数据管理是APP开发的一大难题，因此有很多解决方案供大家使用，比如Redux、Saga、Dva这些，当然也有一些先进的，比如Rematch，或是一些高阶函数、Promise方式，后者是群里听大佬们谈论的，目前还没有实践，不过看了hook这些方式，确实用起来都会省事不少。</li>
<li><a href="https://cn.redux.js.org/" target="_blank" rel="external">Redux、Store、Reducer文档</a></li>
<li><a href="https://redux-saga-in-chinese.js.org/" target="_blank" rel="external">Redux-Saga文档和用法</a></li>
</ul>
</li>
<li><p>拓展使用替代Redux方案，Rematch</p>
<ul>
<li>Rematch是 在 Redux 的基础上构建并减少了样板代码和执行了一些最佳实践，使用rematch可以不用写一堆types、action、store、saga等，写完项目交流的时候发现的，目前我们项目用的还是老一套Redux、Saga、Reducer，写起来type、saga，state等状态是真的痛苦，或许Rematch是更好的选择。</li>
<li><a href="https://rematch.gitbook.io/handbook/" target="_blank" rel="external">Rematch官方文档</a></li>
</ul>
</li>
</ul>
<h3 id="React-Native-基础"><a href="#React-Native-基础" class="headerlink" title="React Native 基础"></a>React Native 基础</h3><ul>
<li><p>有了以上基础，写基础的页面应该不是啥大问题，而对于RN开发，则需要学习对应的文档，了解一些基础的UI组件使用、组件复用、网络请求、flexbox布局、数据存储（AsyncStorage）、loading加载、手机适配、与原生IOS、安卓交互等。</p>
</li>
<li><p>往远了说，在一切页面布局开始写的时候，同时应该规划好接口的调用和字段、mock数据格式、数据的持久化、打包的方式、热更新等。</p>
</li>
<li><p>RN基础之环境安装</p>
<ul>
<li>RN中文网，入门就是教你如何搭建环境，有win版和macos版，基本按着流程走不会出太大的问题，都可以跑起来初始化的项目。</li>
<li><a href="https://www.react-native.cn/docs/getting-started" target="_blank" rel="external">React Native开发环境搭建指南</a></li>
<li>此处可能遇到的问题，如果是iOS，则可能出现CocoaPods版本问题、超时问题、选择master版本问题、更多问题可以看<a href="https://github.com/CocoaPods/CocoaPods/issues" target="_blank" rel="external">issues</a>,brew 比较慢的问题，基本都是网的问题，推荐使用清华源，<a href="https://www.jianshu.com/p/62f1b963baa6" target="_blank" rel="external">brew update无反应</a>,或者直接上代理，并设置git的拉取方式，设置socks5代理端口，此方式同理适用npm、git clone,<a href="https://gist.github.com/laispace/666dd7b27e9116faece6" target="_blank" rel="external">如何设置git socks5端口</a>。</li>
<li>如果是安装安卓版本，则可能遇到sdk版本问题，java jdk需要1.8（java8）版本，然后安装Android Studio 需翻墙，否则网站都进不去.安卓环境90%都是网络问题，这里翻墙情况下推荐使用电信网络，移动可能卡住不动。</li>
<li><a href="https://speedsss.com/auth/register?ref=kP782G" target="_blank" rel="external">推荐一个稳定的机场,speed</a></li>
</ul>
</li>
<li><p>组件化和组件复用</p>
<ul>
<li>RN和Flutter差不多，都是一切组件化，因此在开发的时候，则需要组件化，最终拼接一切完成设计稿里的页面样式，组件复用会很大程度上减少耦合，加快开发进度，减少工作时间，规划好组件复用会事半功倍。</li>
<li>一般情况下：列表、交互、loading、toast会复用的比较多，比如一些Button、列表渲染、line、layout、layoutscroll、TouchableOpacity交互等一些常用的组件，应该让他们独立出来复用。</li>
</ul>
</li>
<li><p>数据请求和数据持久化</p>
<ul>
<li>http请求一般使用axios，封装post、get，请求头等参数，根据不同需求使用即可</li>
<li>数据持久化，推荐使用AsyncStorage+reducer，可以安卓、ios同时适配，也是官方的包。</li>
</ul>
</li>
<li><p>RN 路由、Bottom </p>
<ul>
<li>推荐使用<a href="https://reactnavigation.org/docs/getting-started" target="_blank" rel="external">React Navigation</a>，功能全，生态完善，版本在持续升级，不过坑的是可能新旧版本语法不一样。</li>
<li>备选：<a href="https://wix.github.io/react-native-navigation/docs/before-you-start" target="_blank" rel="external">Wix React Navigation</a>,有基础的功能，不过功能不如React Navigation 功能强大，相对的github也不如React Navigation活跃度高。</li>
</ul>
</li>
</ul>
<h3 id="IOS开发者账号和Xcode使用基础"><a href="#IOS开发者账号和Xcode使用基础" class="headerlink" title="IOS开发者账号和Xcode使用基础"></a>IOS开发者账号和Xcode使用基础</h3><ul>
<li><p><a href="https://www.jianshu.com/p/083c72de47b0" target="_blank" rel="external">Xcode打包IOS之证书签名配置</a> </p>
</li>
<li><p><a href="https://www.devio.org/2020/03/15/React-Native-releases-packaged-iOS-apps-for-apps/" target="_blank" rel="external">iOS 打包发布最新流程</a></p>
</li>
<li>注意事项，一般情况下不要升级Xcode，否则会导致项目跑不起来，同理安卓AS也一样，IOS开发者账号可能会遇到签名问题、添加测试机设备、打包AD hoc包等问题。</li>
<li>一般情况下添加新的udid之后需要重新配置Profiles,选择已经添加的设备之后，一直下一步，最后通过Xcode导入当前下载的证书，然后重新打包hoc包即可。</li>
<li>Xcode 模拟器或真机调试时需要开启:<code>automatically manage signing</code>,并选择开发者账号和已经配置的Profiles，然后设置Build Settings 搜索sign，设置debug和release的四个选项为<code>Apple Development</code>,重新打包启动即可。</li>
<li>更多ios开发遇到的问题，请查看同时间发布的其他文章，或者加<a href="https://t.me/kkdelos" target="_blank" rel="external">TG</a>咨询我。</li>
</ul>
<h3 id="Android-Studio使用和配置"><a href="#Android-Studio使用和配置" class="headerlink" title="Android Studio使用和配置"></a>Android Studio使用和配置</h3><ul>
<li>安卓环境基本按照官方文档都可以顺利完成，并跑起来，而更多的坑则是后期开发中需要设置xml配置，gradle配置，引用第三方包需要增加配置等问题。</li>
<li>关于安卓开发中遇到的问题，请查看:”RN小技巧记录系列文章”。</li>
</ul>
<h3 id="API调试"><a href="#API调试" class="headerlink" title="API调试"></a>API调试</h3><ul>
<li>接口调试也是前端必备技能，毕竟数据不能只使用假的，而对于调试接口，则需要看后端如何提供稳定，比如java、go、php都有swag在线调试，而对于没有swag的则可以使用postman发请求看接口的情况，当然你也可以直接使用axios去调试。</li>
<li>在高端一点，可以使用抓包工具<code>Charles、Fiddler</code>等抓包工具查看返回情况和请求情况。</li>
</ul>
<h3 id="翻墙工具"><a href="#翻墙工具" class="headerlink" title="翻墙工具"></a>翻墙工具</h3><ul>
<li>万恶的GFW，真是难为了国内的广大开发者。</li>
<li>推荐使用，有钱可以直接上Surge，要不就选V2ray、Trojan模式</li>
<li>客户端推荐使用：<a href="https://github.com/yichengchen/clashX/releases" target="_blank" rel="external">ClashX</a>、Shadowrocket、Quantumult X、<a href="https://github.com/Cenmrev/V2RayX/releases" target="_blank" rel="external">V2RayX</a></li>
<li>科学上网的方式<ul>
<li>自建：推荐使用Vultr，<a href="https://www.vultr.com/?ref=8557913-6G" target="_blank" rel="external">快速注册Vultr获取100美元测试金</a></li>
</ul>
</li>
<li>机场千万家如何选？<ul>
<li>不想折腾就买稳定的，否则就白嫖吧，反正不花钱,网上有很多分享ss的不过不是很安全。</li>
<li><a href="https://speed17.com/#/register?code=llNeSueq" target="_blank" rel="external">注册白嫖版，邀请码过期请评论区留言</a></li>
<li><a href="https://v2.qovoq.ml/#/register?code=EWAnpomv" target="_blank" rel="external">注册便宜版V2ray</a></li>
<li><a href="https://speedsss.com/auth/register?ref=kP782G" target="_blank" rel="external">注册稳定付费版V2ray，支持Clashx</a></li>
</ul>
</li>
</ul>
<h3 id="拓展学习"><a href="#拓展学习" class="headerlink" title="拓展学习"></a>拓展学习</h3><ul>
<li><a href="https://fullstackopen.com/zh/part9" target="_blank" rel="external">Typescript基础入门</a></li>
<li><a href="https://pan.baidu.com/s/1flEC_MvIYXAVDo94WesCSw" target="_blank" rel="external">开课吧web全栈架构师第4期</a>, 提取码: az94</li>
<li><a href="https://pan.baidu.com/s/19XDotXphjuViwJzJFiW5Rg" target="_blank" rel="external">seo魔贝8期</a>, 提取码: qnua</li>
</ul>
<h3 id="RN相关博客推荐"><a href="#RN相关博客推荐" class="headerlink" title="RN相关博客推荐"></a>RN相关博客推荐</h3><ul>
<li><a href="https://www.devio.org/tags/#React%20Native" target="_blank" rel="external">贾鹏辉的技术博客，RN开发部分</a></li>
<li><a href="https://trello.com/b/Lbq1o6L9/learning-react-native" target="_blank" rel="external">trello上的RN指南和讨论</a></li>
<li><a href="https://reactnativeexample.com/" target="_blank" rel="external">RN的一些组件和demo事例</a></li>
<li><a href="https://react.parts/" target="_blank" rel="external">React和React Native组件库</a></li>
<li><a href="https://react.iamkasong.com/#" target="_blank" rel="external">React技术揭秘</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一个新手需要哪些基础知识上手RN开发？&quot;&gt;&lt;a href=&quot;#一个新手需要哪些基础知识上手RN开发？&quot; class=&quot;headerlink&quot; title=&quot;一个新手需要哪些基础知识上手RN开发？&quot;&gt;&lt;/a&gt;一个新手需要哪些基础知识上手RN开发？&lt;/h3&gt;&lt;ul&gt;

    
    </summary>
    
      <category term="react" scheme="http://idiot6.com/categories/react/"/>
    
    
      <category term="ios" scheme="http://idiot6.com/tags/ios/"/>
    
      <category term="dart" scheme="http://idiot6.com/tags/dart/"/>
    
      <category term="React native" scheme="http://idiot6.com/tags/React-native/"/>
    
      <category term="flutter" scheme="http://idiot6.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>React Native打包安卓和Ipa指南，RN小技巧记录</title>
    <link href="http://idiot6.com/2020/07/19/React%20Native%E6%89%93%E5%8C%85%E5%AE%89%E5%8D%93%E5%92%8CIpa%E6%8C%87%E5%8D%97%EF%BC%8CRN%E5%B0%8F%E6%8A%80%E5%B7%A7%E8%AE%B0%E5%BD%95/"/>
    <id>http://idiot6.com/2020/07/19/React Native打包安卓和Ipa指南，RN小技巧记录/</id>
    <published>2020-07-19T07:55:53.000Z</published>
    <updated>2020-07-19T08:26:58.111Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CSS小技巧之文字实现竖排"><a href="#CSS小技巧之文字实现竖排" class="headerlink" title="CSS小技巧之文字实现竖排"></a>CSS小技巧之文字实现竖排</h3><ul>
<li><p>设置外层宽度，然后定位文字，给文字设置css行高（lineHeight应大于外层文字高度）</p>
<h3 id="IOS相关"><a href="#IOS相关" class="headerlink" title="IOS相关"></a>IOS相关</h3></li>
<li><p><code>error Failed to build iOS project. We ran &quot;xcodebuild&quot; command but it exited with error code 65. To debug build logs further, consider building your app with Xcode.app, by opening cleaaan.xcworkspace</code></p>
</li>
<li><p>碰到code 65 可能和ios包管理有关，<code>cd ios &amp;&amp; pod repo update &amp;&amp; pod install &amp;&amp; pod update</code></p>
</li>
<li><p>ios键盘遮挡问题，使用APSL下组件：<code>[react-native-keyboard-aware-scrollview](https://github.com/APSL/react-native-keyboard-aware-scroll-view)</code> </p>
</li>
</ul>
<h3 id="JS相关"><a href="#JS相关" class="headerlink" title="JS相关"></a>JS相关</h3><ul>
<li><code>TypeError: Invalid attempt to spread non-iterable instance</code></li>
<li>可能原因是数据和对象转换赋值导致不能遍历这个数据的问题，检查接口获取到之后的数据和当前state定义的数据之间互相赋值是否加了[…aaa],aaa为state定义的数组或对象，这里的…可能是导致错误出现的原因，去掉试试。</li>
</ul>
<h3 id="React-Native-ios打包-IPA"><a href="#React-Native-ios打包-IPA" class="headerlink" title="React Native ios打包 IPA"></a>React Native ios打包 IPA</h3><ul>
<li><p><code>mkdir release_ios</code></p>
</li>
<li><p><code>npx react-native bundle --entry-file index.js --platform ios --dev false --bundle-output release_ios/main.jsbundle --assets-dest release_ios/</code></p>
</li>
</ul>
<ul>
<li><code>release_ios</code> 下的文件 添加到xcode项目，xx项目名 -》 add files to xxx项目 -&gt;选择目录<code>release_ios-》folders</code>类型为<code>“Create folder references” -》 Add</code></li>
</ul>
<ul>
<li>添加证书、配置描述文件打包 -》·product -&gt;archive =&gt; Distribute App· =&gt; 然后有4个选择，IOS App Store 上架、Development 测试，Enterprise 企业包，然后一直下一步，导出ipa</li>
</ul>
<h3 id="React-Native-安卓打包APK"><a href="#React-Native-安卓打包APK" class="headerlink" title="React Native 安卓打包APK"></a>React Native 安卓打包APK</h3><ul>
<li>1.生成keystore</li>
<li>2.设置 gradle 变量</li>
<li>3.将签名配置加入到项目的 gradle 配置中</li>
<li><ol>
<li><code>cd  android</code></li>
</ol>
</li>
<li><ol>
<li><code>./gradlew assembleRelease</code></li>
</ol>
</li>
<li><p>keytool -genkeypair -v -keystore my-release-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000</p>
</li>
</ul>
<p>更多详细操作步骤推荐参考：</p>
<ul>
<li><a href="https://www.react-native.cn/docs/signed-apk-android" target="_blank" rel="external">React Native 官方打包APK</a></li>
<li><p><a href="https://www.devio.org/2019/11/08/react-native-Release-APP-Signature-Package-APK/" target="_blank" rel="external">新版React Native发布APP之签名打包APK</a></p>
</li>
<li><p>Notice：Macos下可能需要sudo </p>
<ul>
<li>执行 sudo ./gradlew assembleRelease</li>
</ul>
</li>
</ul>
<h3 id="安卓打包线上realease版本安装后不能发起请求http问题"><a href="#安卓打包线上realease版本安装后不能发起请求http问题" class="headerlink" title="安卓打包线上realease版本安装后不能发起请求http问题"></a>安卓打包线上realease版本安装后不能发起请求http问题</h3><ul>
<li>安卓打包realease版本后，默认 ReactNative Android9.0以上打包apk后http无法请求</li>
</ul>
<p><img src="media/15944435878136/15951436861022.jpg" alt="AndroidManifest.xml"></p>
<ul>
<li>修改 <code>/当前项目名/android/app/src/main/AndroidManifest.xml</code>，增加配置在application中 <code>android:usesCleartextTraffic=&quot;true&quot;</code></li>
</ul>
<h3 id="RN开发参考和React相关技术栈推荐"><a href="#RN开发参考和React相关技术栈推荐" class="headerlink" title="RN开发参考和React相关技术栈推荐"></a>RN开发参考和React相关技术栈推荐</h3><ul>
<li><a href="https://www.react-native.cn/" target="_blank" rel="external">React Native中文网</a></li>
<li><a href="https://reactnativeexample.com/" target="_blank" rel="external">RN常用例子和demo</a></li>
<li><a href="https://shenbao.github.io/ishehui/index.html" target="_blank" rel="external">React和RN技术、RN速查表，强烈推荐查看</a></li>
<li><a href="https://cn.redux.js.org/" target="_blank" rel="external">Store、Redux、Reducer、action等数据相关知识，必学必看</a></li>
<li><a href="https://react.iamkasong.com/" target="_blank" rel="external">React 源码技术揭秘</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CSS小技巧之文字实现竖排&quot;&gt;&lt;a href=&quot;#CSS小技巧之文字实现竖排&quot; class=&quot;headerlink&quot; title=&quot;CSS小技巧之文字实现竖排&quot;&gt;&lt;/a&gt;CSS小技巧之文字实现竖排&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设置外层宽度，然后定位文字，给文字
    
    </summary>
    
      <category term="react" scheme="http://idiot6.com/categories/react/"/>
    
    
      <category term="ios" scheme="http://idiot6.com/tags/ios/"/>
    
      <category term="React native" scheme="http://idiot6.com/tags/React-native/"/>
    
      <category term="vscode" scheme="http://idiot6.com/tags/vscode/"/>
    
      <category term="rn开发" scheme="http://idiot6.com/tags/rn%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>flutter 问题汇总</title>
    <link href="http://idiot6.com/2020/07/19/flutter%20%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://idiot6.com/2020/07/19/flutter 问题汇总/</id>
    <published>2020-07-19T07:23:53.000Z</published>
    <updated>2020-07-19T08:26:58.193Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>flutter doctor 一直卡住不动，可能是代理问题<ul>
<li>export PUB_HOSTED_URL=<a href="https://pub.flutter-io.cn" target="_blank" rel="external">https://pub.flutter-io.cn</a></li>
<li>export FLUTTER_STORAGE_BASE_URL=<a href="https://storage.flutter-io.cn" target="_blank" rel="external">https://storage.flutter-io.cn</a></li>
</ul>
</li>
</ul>
<p>macos/linux 设置中国镜像：   每次都要先执行一次 （export PATH=”$PWD/flutter/bin:$PATH”）</p>
<ol>
<li>export PUB_HOSTED_URL=<a href="https://pub.flutter-io.cn" target="_blank" rel="external">https://pub.flutter-io.cn</a></li>
<li>export FLUTTER_STORAGE_BASE_URL=<a href="https://storage.flutter-io.cn" target="_blank" rel="external">https://storage.flutter-io.cn</a></li>
<li>git clone -b dev <a href="https://github.com/flutter/flutter.git" target="_blank" rel="external">https://github.com/flutter/flutter.git</a></li>
<li>export PATH=”$PWD/flutter/bin:$PATH”</li>
<li>cd ./flutter</li>
<li>flutter doctor</li>
</ol>
<p>然后运行flutter doctor -v 更新版本</p>
<p>flutter 环境之java环境，必须使用jdk8，否则会一直提示升级。</p>
<p>git clone 加速</p>
<p>git config –global http.<a href="https://github.com.proxy" target="_blank" rel="external">https://github.com.proxy</a> socks5://127.0.0.1:7891<br>或者打开 .gitconfig 文件，输入下面配置</p>
<p>[http “<a href="https://github.com" target="_blank" rel="external">https://github.com</a>“]<br>    proxy = socks5://127.0.0.1:1086</p>
<ul>
<li><p>Waiting for another flutter command to release the startup lock…</p>
<ul>
<li>进入到你的flutter sdk目录中，然后找到bin/cache/lockfile文件，删除它即可。</li>
</ul>
</li>
</ul>
<p>CDN: trunk URL couldn’t be downloaded:<br>      <a href="https://raw.githubusercontent.com" target="_blank" rel="external">https://raw.githubusercontent.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;flutter doctor 一直卡住不动，可能是代理问题&lt;ul&gt;
&lt;li&gt;export PUB_HOSTED_URL=&lt;a href=&quot;https://pub.flutter-io.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http
    
    </summary>
    
      <category term="flutter" scheme="http://idiot6.com/categories/flutter/"/>
    
    
      <category term="ios" scheme="http://idiot6.com/tags/ios/"/>
    
      <category term="dart" scheme="http://idiot6.com/tags/dart/"/>
    
      <category term="React native" scheme="http://idiot6.com/tags/React-native/"/>
    
      <category term="flutter" scheme="http://idiot6.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>dart 基础</title>
    <link href="http://idiot6.com/2020/06/19/dart%20%E5%9F%BA%E7%A1%80/"/>
    <id>http://idiot6.com/2020/06/19/dart 基础/</id>
    <published>2020-06-19T06:03:53.000Z</published>
    <updated>2020-07-19T08:26:58.191Z</updated>
    
    <content type="html"><![CDATA[<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><ul>
<li>var 关键字</li>
<li><p>强类型语言，声明后无法改变</p>
<pre><code>var z;
z = &quot;hello world&quot;;
// 下面代码在dart中会报错，因为变量t的类型已经确定为String，
// 类型一旦确定后则不能再更改其类型。
z = 1000;
</code></pre></li>
<li><p>dynamic和Object</p>
<ul>
<li>Object 是Dart所有对象的根基类，也就是说所有类型都是Object的子类(包括Function和Null)，所以任何类型的数据都可以赋值给Object声明的对象. dynamic与var一样都是关键词,声明的变量可以赋值任意对象。 </li>
<li>dynamic与Object相同之处:”在于,他们声明的变量可以在后期改变赋值类型。”</li>
<li>dynamic与Object不同的是:”dynamic声明的对象编译器会提供所有可能的组合, 而Object声明的对象只能使用Object的属性与方法, 否则编译器会报错”<br>dynamic t;<br>Object x;<br>t = “hello world”;<br>x = ‘Hello Object’;<br>//下面代码没有问题<br>t = 1000;<br>x = 1000;</li>
</ul>
<ul>
<li>final和const<ul>
<li>不改变变量类型或值，初始化就固定</li>
<li>final 或 const，不是var，也不是一个类型。 一个 final 变量只能被设置一次</li>
<li>两者区别在于：const 变量是一个编译时常量，final变量在第一次使用时被初始化。被final或者const修饰的变量，变量类型可以省略</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>//可以省略String这个类型声明<br>final str = “hi world”;<br>//final String str = “hi world”;<br>const str1 = “hi world”;<br>//const String str1 = “hi world”;</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>Dart是一种真正的面向对象的语言，所以即使是函数也是对象，并且有一个类型Function。这意味着函数可以赋值给变量或作为参数传递给其他函数，这是函数式编程的典型特征。</li>
<li>声明一个函数：</li>
</ul>
<p>bool isNoble(int atomicNumber) {<br>  return _nobleGases[atomicNumber] != null;<br>}</p>
<ul>
<li><p>Dart函数声明如果没有显式声明返回值类型时会默认当做“dynamic处理”，注意，函数返回值没有类型推断！</p>
</li>
<li><p>对于只包含一个表达式的函数，可以使用简写语法</p>
</li>
</ul>
<p>bool isNoble (int atomicNumber)=&gt; _nobleGases [ atomicNumber ] ！= null ;</p>
<ul>
<li>函数可以作为变量：</li>
</ul>
<p>var say = (str){<br>  print(str);<br>};<br>say(“hi world”);</p>
<ul>
<li>函数作为参数传递：</li>
</ul>
<p>void execute(var callback) {<br>    callback();<br>}<br>execute(() =&gt; print(“xxx”))</p>
<ul>
<li>可选的位置参数<ul>
<li>包装一组函数参数，用[]标记为可选的位置参数，并放在参数列表的最后面：</li>
</ul>
</li>
</ul>
<p>String say(String from, String msg, [String device]) {<br>  var result = ‘$from says $msg’;<br>  if (device != null) {<br>    result = ‘$result with a $device’;<br>  }<br>  return result;<br>}</p>
<p>测试=》say(‘Bob’, ‘Howdy’); //结果是： Bob says Howdy</p>
<p>测试=&gt; say(‘Bob’, ‘Howdy’, ‘smoke signal’); //结果是：Bob says Howdy with a smoke signal</p>
<ul>
<li><strong>可选的命名参数(用的比较多)</strong><ul>
<li>定义函数时，使用{param1, param2, …}，放在参数列表的最后面，用于指定命名参数。例如：</li>
</ul>
</li>
</ul>
<p>//设置[bold]和[hidden]标志<br>void enableFlags({bool bold, bool hidden}) {<br>    // …<br>}</p>
<ul>
<li>调用函数时，可以使用指定命名参数。例如：paramName: value</li>
</ul>
<p>enableFlags(bold: true, hidden: false);</p>
<p><strong>注意，不能同时使用可选的位置参数和可选的命名参数</strong></p>
<h3 id="异步支持"><a href="#异步支持" class="headerlink" title="异步支持"></a>异步支持</h3><ul>
<li><p>Dart类库有非常多的返回Future或者Stream对象的函数。 这些函数被称为异步函数：它们只会在设置好一些耗时操作之后返回，比如像 IO操作。而不是等到这个操作完成。</p>
</li>
<li><p>async和await关键词支持了异步编程，允许您写出和同步代码很像的异步代码。</p>
</li>
<li><p>Future</p>
<ul>
<li>Future与JavaScript中的Promise非常相似，表示一个异步操作的最终完成（或失败）及其结果值的表示。</li>
<li>简单来说，它就是用于处理异步操作的，异步处理成功了就执行成功的操作，异步处理失败了就捕获错误或者停止后续操作。</li>
<li>一个Future只会对应一个结果，要么成功，要么失败。</li>
<li>Future的所有API的返回值仍然是一个Future对象，所以可以很方便的进行链式调用。</li>
</ul>
</li>
<li><p>Future API及特性 例子讲解</p>
<ul>
<li>Future.then  成功返回</li>
<li>Future.catchError 捕捉错误</li>
<li>Future.whenComplete 请求的中途想干些事</li>
<li>Future.wait 等待所有的Future成功才会走这里</li>
<li>因为只有成功和失败，捕捉到错误then方法不在执行</li>
</ul>
</li>
</ul>
<p>// 延迟2s返回结果：”hi world!”<br>Future.delayed(new Duration(seconds: 2),(){<br>   return “hi world!”;<br>}).then((data){<br>    // 执行成功走这<br>   print(data);<br>}).catchError((e){<br>   //执行失败会走到这里<br>   print(e);<br>}).whenComplete((){<br>   //无论成功或失败都会走到这里<br>});<br>// wait等待结果，4s后看到hello world<br>Future.wait([<br>  // 2秒后返回结果<br>  Future.delayed(new Duration(seconds: 2), () {<br>    return “hello”;<br>  }),<br>  // 4秒后返回结果<br>  Future.delayed(new Duration(seconds: 4), () {<br>    return “ world”;<br>  })<br>]).then((results){<br>  print(results[0]+results[1]);<br>}).catchError((e){<br>  print(e);<br>});</p>
<ul>
<li>Async/await<ul>
<li>同步方法写异步代码，利用Dart的Future返回都是Future特性可以连续调用，也可以直接用Async/await形式</li>
</ul>
</li>
</ul>
<p>// 登陆之后保存用户信息<br>task() async {<br>   try{<br>    String id = await login(“alice”,”<strong>**</strong>“);<br>    String userInfo = await getUserInfo(id);<br>    await saveUserInfo(userInfo);<br>    //执行接下来的操作<br>   } catch(e){<br>    //错误处理<br>    print(e);<br>   }<br>}</p>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><ul>
<li>也是用于接收异步事件数据，和Future 不同的是，它可以接收多个异步操作的结果（成功或失败）。 </li>
<li>也就是说，在执行异步任务时，可以通过多次触发成功或失败事件来传递结果数据或错误异常。 </li>
<li>Stream 常用于会多次读取数据的异步任务场景，如网络内容下载、文件读写等。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;变量声明&quot;&gt;&lt;a href=&quot;#变量声明&quot; class=&quot;headerlink&quot; title=&quot;变量声明&quot;&gt;&lt;/a&gt;变量声明&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;var 关键字&lt;/li&gt;
&lt;li&gt;&lt;p&gt;强类型语言，声明后无法改变&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var z;

    
    </summary>
    
      <category term="flutter" scheme="http://idiot6.com/categories/flutter/"/>
    
    
      <category term="ios" scheme="http://idiot6.com/tags/ios/"/>
    
      <category term="dart" scheme="http://idiot6.com/tags/dart/"/>
    
      <category term="React native" scheme="http://idiot6.com/tags/React-native/"/>
    
      <category term="flutter" scheme="http://idiot6.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 基础</title>
    <link href="http://idiot6.com/2020/05/29/Flutter%20%E5%9F%BA%E7%A1%80/"/>
    <id>http://idiot6.com/2020/05/29/Flutter 基础/</id>
    <published>2020-05-29T15:58:53.000Z</published>
    <updated>2020-07-19T08:26:58.111Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Stateful-widget-和Stateless-widget"><a href="#Stateful-widget-和Stateless-widget" class="headerlink" title="Stateful widget 和Stateless widget"></a>Stateful widget 和Stateless widget</h3><ul>
<li>有状态的组件（Stateful widget） 和无状态的组件（Stateless widget）有两点不同：<ul>
<li>Stateful widget可以拥有状态，这些状态在widget生命周期中是可以变的，而Stateless widget是不可变的。</li>
<li>Stateful widget至少由两个类组成：<ul>
<li>一个StatefulWidget类。</li>
<li>一个 State类； StatefulWidget类本身是不变的，但是State类中持有的状态在widget生命周期中可能会发生变化。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Navigator，MaterialPageRoute-》路由管理"><a href="#Navigator，MaterialPageRoute-》路由管理" class="headerlink" title="Navigator，MaterialPageRoute=》路由管理"></a>Navigator，MaterialPageRoute=》路由管理</h3><ul>
<li><p>路由(Route)在移动开发中通常指页面（Page），这跟web开发中单页应用的Route概念意义是相同的，Route在Android中通常指一个Activity，在iOS中指一个ViewController。所谓路由管理，就是管理页面之间如何跳转，通常也可被称为导航管理。</p>
</li>
<li><p>导航管理都会维护一个路由栈，路由入栈(push)操作对应打开一个新页面，路由出栈(pop)操作对应页面关闭操作，而路由管理主要是指如何来管理路由栈。</p>
</li>
</ul>
<p>// 路由跳转例子，调用Navigator.push方法，return到一个新的路由页面（NewRoute）</p>
<p>onPressed: () {<br>  //导航到新路由<br>  Navigator.push( context,<br>   MaterialPageRoute(builder: (context) {<br>      return NewRoute();<br>   }));<br>},</p>
<ul>
<li><p>路由之=》MaterialPageRoute</p>
<ul>
<li><p>MaterialPageRoute继承自PageRoute类，PageRoute类是一个抽象类，表示占有整个屏幕空间的一个模态路由页面，它还定义了路由构建及切换时过渡动画的相关接口及属性。MaterialPageRoute 是Material组件库提供的组件，它可以针对不同平台，实现与平台页面切换动画风格一致的路由切换动画：</p>
</li>
<li><p>对于Android，当打开新页面时，新的页面会从屏幕底部滑动到屏幕顶部；当关闭页面时，当前页面会从屏幕顶部滑动到屏幕底部后消失，同时上一个页面会显示到屏幕上。</p>
</li>
<li>对于iOS，当打开页面时，新的页面会从屏幕右侧边缘一致滑动到屏幕左边，直到新页面全部显示到屏幕上，而上一个页面则会从当前屏幕滑动到屏幕左侧而消失；当关闭页面时，正好相反，当前页面会从屏幕右侧滑出，同时上一个页面会从屏幕左侧滑入。</li>
</ul>
</li>
<li><p>MaterialPageRoute使用参数介绍</p>
</li>
</ul>
<p>MaterialPageRoute({<br>    WidgetBuilder builder,<br>    RouteSettings settings,<br>    bool maintainState = true,<br>    bool fullscreenDialog = false,<br>})</p>
<p>builder 是一个WidgetBuilder类型的回调函数，它的作用是构建路由页面的具体内容，返回值是一个widget。我们通常要实现此回调，返回新路由的实例。</p>
<p>settings 包含路由的配置信息，如路由名称、是否初始路由（首页）。</p>
<p>maintainState：默认情况下，当入栈一个新路由时，原来的路由仍然会被保存在内存中，如果想在路由没用的时候释放其所占用的所有资源，可以设置maintainState为false。</p>
<p>fullscreenDialog表示新的路由页面是否是一个全屏的模态对话框，在iOS中，如果<br>fullscreenDialog为true，新页面将会从屏幕底部滑入（而不是水平方向）。</p>
<ul>
<li><p>路由之Navigator</p>
<ul>
<li>Navigator是一个路由管理的组件，它提供了打开和退出路由页方法。Navigator通过一个栈来管理活动路由集合。通常当前屏幕显示的页面就是栈顶的路由。Navigator提供了一系列方法来管理路由栈，在此我们只介绍其最常用的两个方法：<ul>
<li>Future push(BuildContext context, Route route)</li>
<li>将给定的路由入栈（即打开新的页面），返回值是一个Future对象，用以接收新路由出栈（即关闭）时的返回数据。</li>
<li>bool pop(BuildContext context, [ result ])</li>
<li>将栈顶路由出栈，result为页面关闭时返回给上一个页面的数据。</li>
</ul>
</li>
</ul>
</li>
<li><p>判断用户是否登陆，onGenerateRoute属性</p>
<ul>
<li>它在打开命名路由时可能会被调用，之所以说可能，是因为当调用Navigator.pushNamed(…)打开命名路由时，如果指定的路由名在路由表中已注册，则会调用路由表中的builder函数来生成路由组件；如果路由表中没有注册，才会调用onGenerateRoute来生成路由。</li>
<li>全局的路由跳转前置处理逻辑。</li>
</ul>
</li>
</ul>
<h3 id="pubspec之-包管理"><a href="#pubspec之-包管理" class="headerlink" title="pubspec之 包管理"></a>pubspec之 包管理</h3><ul>
<li><p>flutter如何使用配置文件pubspec.yaml（位于项目根目录）来管理第三方依赖包。</p>
</li>
<li><p>YAML是一种直观、可读性高并且容易被人类阅读的文件格式，它和xml或Json相比，它语法简单并非常容易解析，所以YAML常用于配置文件，Flutter也是用yaml文件作为其配置文件。</p>
</li>
<li>yaml例子和参数说明：<ul>
<li>name：应用或包名称。</li>
<li>description: 应用或包的描述、简介。</li>
<li>version：应用或包的版本号。</li>
<li>dependencies：应用或包依赖的其它包或插件。</li>
<li>dev_dependencies：开发环境依赖的工具包（而不是flutter应用本身依赖的包）。</li>
<li>flutter：flutter相关的配置选项。</li>
</ul>
</li>
<li>dependencies和dev_dependencies的区别，前者的依赖包将作为APP的源码的一部分参与编译，生成最终的安装包。而后者的依赖包只是作为开发阶段的一些工具包，主要是用于帮助我们提高开发、测试效率，比如flutter的自动化测试包等</li>
</ul>
<p>name: flutter_in_action<br>description: First Flutter application.</p>
<p>version: 1.0.0+1</p>
<p>dependencies:<br>  flutter:<br>    sdk: flutter<br>  cupertino_icons: ^0.1.2<br>  // 新添加的依赖<br>  english_words: ^3.1.3<br>dev_dependencies:<br>  flutter_test:<br>    sdk: flutter</p>
<p>flutter:<br>  uses-material-design: true</p>
<ul>
<li>如何使用新包：直接将所依赖的包添加到dependencies下，然后运行：flutter packages get<h3 id="pubspec-之资源管理"><a href="#pubspec-之资源管理" class="headerlink" title="pubspec 之资源管理"></a>pubspec 之资源管理</h3></li>
<li>assets指定应包含在应用程序中的文件， 每个asset都通过相对于pubspec.yaml文件所在的文件系统路径来标识自身的路径。asset的声明顺序是无关紧要的，asset的实际目录可以是任意文件夹（在本示例中是assets文件夹）。</li>
<li><p>flutter:<br>assets:</p>
<ul>
<li>images/my_icon.png</li>
<li>images/background.png</li>
</ul>
</li>
<li><p>加载当前在pubspec设置的assets图路径,两种方法都可以</p>
</li>
</ul>
<p>Image(<br>  image: AssetImage(“images/my_icon.png”),<br>  width: 100.0<br>);</p>
<p>Image.asset(“images/avatar.png”,<br>  width: 100.0,<br>)</p>
<ul>
<li>加载网络图片：</li>
</ul>
<p>Image(<br>  image: NetworkImage(<br>      “<a href="https://avatars2.githubusercontent.com/u/20411648?s=460&amp;v=4" target="_blank" rel="external">https://avatars2.githubusercontent.com/u/20411648?s=460&amp;v=4</a>“),<br>  width: 100.0,<br>)</p>
<p>Image.network(<br>  “<a href="https://avatars2.githubusercontent.com/u/20411648?s=460&amp;v=4" target="_blank" rel="external">https://avatars2.githubusercontent.com/u/20411648?s=460&amp;v=4</a>“,<br>  width: 100.0,<br>)</p>
<ul>
<li>Image参数介绍</li>
</ul>
<p>const Image({<br>  …<br>  this.width, //图片的宽<br>  this.height, //图片高度<br>  this.color, //图片的混合色值<br>  this.colorBlendMode, //混合模式<br>  this.fit,//缩放模式<br>  this.alignment = Alignment.center, //对齐方式<br>  this.repeat = ImageRepeat.noRepeat, //重复方式<br>  …<br>})</p>
<h3 id="Pub仓库"><a href="#Pub仓库" class="headerlink" title="Pub仓库"></a>Pub仓库</h3><ul>
<li>Pub（<a href="https://pub.dev/" target="_blank" rel="external">https://pub.dev/</a> ）是Google官方的Dart Packages仓库，类似于node中的npm仓库，android中的jcenter。我们可以在Pub上面查找我们需要的包和插件，也可以向Pub发布我们的包和插件。</li>
</ul>
<h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><ul>
<li><p>官方给出的一些原则可以帮助你做决定：</p>
<ul>
<li>如果状态是用户数据，如复选框的选中状态、滑块的位置，则该状态最好由父Widget管理。</li>
<li>如果状态是有关界面外观效果的，例如颜色、动画，那么状态最好由Widget本身来管理。</li>
<li>如果某一个状态是不同Widget共享的则最好由它们共同的父Widget管理。</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Stateful-widget-和Stateless-widget&quot;&gt;&lt;a href=&quot;#Stateful-widget-和Stateless-widget&quot; class=&quot;headerlink&quot; title=&quot;Stateful widget 和Stateless
    
    </summary>
    
      <category term="flutter" scheme="http://idiot6.com/categories/flutter/"/>
    
    
      <category term="dart" scheme="http://idiot6.com/tags/dart/"/>
    
      <category term="eth" scheme="http://idiot6.com/tags/eth/"/>
    
      <category term="React native" scheme="http://idiot6.com/tags/React-native/"/>
    
      <category term="Truffle" scheme="http://idiot6.com/tags/Truffle/"/>
    
      <category term="dapps" scheme="http://idiot6.com/tags/dapps/"/>
    
  </entry>
  
  <entry>
    <title>响应式编程 RN 优缺点</title>
    <link href="http://idiot6.com/2020/05/27/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%20RN%20%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
    <id>http://idiot6.com/2020/05/27/响应式编程 RN 优缺点/</id>
    <published>2020-05-27T15:54:22.000Z</published>
    <updated>2020-07-19T08:26:58.676Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>React中提出一个重要思想：状态改变则UI随之自动改变，而React框架本身就是响应用户状态改变的事件而执行重新构建用户界面的工作，这就是典型的响应式编程范式，下面我们总结一下React中响应式原理：</p>
</li>
<li><p>开发者只需关注状态转移（数据），当状态发生变化，React框架会自动根据新的状态重新构建UI。<br>React框架在接收到用户状态改变通知后，会根据当前渲染树，结合最新的状态改变，通过Diff算法，计算出树中变化的部分，然后只更新变化的部分（DOM操作），从而避免整棵树重构，提高性能。</p>
</li>
</ul>
<h3 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h3><ul>
<li><p>上文已经提到React Native 是React 在原生移动应用平台的衍生产物，那两者主要的区别是什么呢？其实，主要的区别在于虚拟DOM映射的对象是什么？React中虚拟DOM最终会映射为浏览器DOM树，而RN中虚拟DOM会通过 JavaScriptCore 映射为原生控件树。</p>
</li>
<li><p>JavaScriptCore 是一个JavaScript解释器，它在React Native中主要有两个作用：</p>
<ul>
<li>为JavaScript提供运行环境。</li>
<li>是JavaScript与原生应用之间通信的桥梁，作用和JsBridge一样，事实上，在iOS中，很多JsBridge的实现都是基于 JavaScriptCore 。</li>
</ul>
</li>
<li><p>而RN中将虚拟DOM映射为原生控件的过程中分两步：</p>
<ul>
<li>布局消息传递； 将虚拟DOM布局信息传递给原生；</li>
<li>原生根据布局信息通过对应的原生控件渲染控件树；</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>JavaScript开发+原生渲染的方式主要优点如下：</li>
</ul>
<ol>
<li>采用Web开发技术栈，社区庞大、上手快、开发成本相对较低。</li>
<li>原生渲染，性能相比H5提高很多。</li>
<li>动态化较好，支持热更新。</li>
</ol>
<ul>
<li>不足：</li>
</ul>
<ul>
<li>渲染时需要JavaScript和原生之间通信，在有些场景如拖动可能会因为通信频繁导致卡顿。</li>
<li>JavaScript为脚本语言，执行时需要JIT(Just In Time)，执行效率和AOT(Ahead Of Time)代码仍有差距。</li>
<li>由于渲染依赖原生控件，不同平台的控件需要单独维护，并且当系统更新时，社区控件可能会滞后；除此之外，其控件系统也会受到原生UI系统限制，例如，在Android中，手势冲突消歧规则是固定的，这在使用不同人写的控件嵌套时，手势冲突问题将会变得非常棘手。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;React中提出一个重要思想：状态改变则UI随之自动改变，而React框架本身就是响应用户状态改变的事件而执行重新构建用户界面的工作，这就是典型的响应式编程范式，下面我们总结一下React中响应式原理：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;开发者只需关注状态
    
    </summary>
    
      <category term="react" scheme="http://idiot6.com/categories/react/"/>
    
    
      <category term="dart" scheme="http://idiot6.com/tags/dart/"/>
    
      <category term="eth" scheme="http://idiot6.com/tags/eth/"/>
    
      <category term="React native" scheme="http://idiot6.com/tags/React-native/"/>
    
      <category term="Truffle" scheme="http://idiot6.com/tags/Truffle/"/>
    
      <category term="dapps" scheme="http://idiot6.com/tags/dapps/"/>
    
  </entry>
  
  <entry>
    <title>加密算法系列之：des加密、aes加密、3des加密、对称加密、非对称加密、Hash 算法</title>
    <link href="http://idiot6.com/2020/05/23/%20%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E4%B9%8B%EF%BC%9Ades%E5%8A%A0%E5%AF%86%E3%80%81aes%E5%8A%A0%E5%AF%86%E3%80%813des%E5%8A%A0%E5%AF%86%E3%80%81%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E3%80%81%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E3%80%81Hash%20%E7%AE%97%E6%B3%95/"/>
    <id>http://idiot6.com/2020/05/23/ 加密算法系列之：des加密、aes加密、3des加密、对称加密、非对称加密、Hash 算法/</id>
    <published>2020-05-23T09:03:53.000Z</published>
    <updated>2020-07-19T08:26:58.003Z</updated>
    
    <content type="html"><![CDATA[<h3 id="加密算法导读"><a href="#加密算法导读" class="headerlink" title="加密算法导读"></a>加密算法导读</h3><ul>
<li><p>加密一般分为对称加密(Symmetric Key Encryption)和非对称加密(Asymmetric Key Encryption)</p>
</li>
<li><p>常见的对称加密算法：DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6 和 AES</p>
</li>
<li><p>常见的非对称加密算法：RSA、ECC （移动设备用）、Diffie-Hellman、El Gamal、DSA （数字签名用）</p>
</li>
<li><p>常见的 Hash 算法：MD2、MD4、MD5、HAVAL、SHA、SHA-1、HMAC、HMAC-MD5、HMAC-SHA1</p>
</li>
<li><p>分组加密算法中，有ECB,CBC,CFB,OFB这几种算法模式</p>
</li>
</ul>
<h3 id="什么是对称密码算法"><a href="#什么是对称密码算法" class="headerlink" title="什么是对称密码算法"></a>什么是对称密码算法</h3><ul>
<li><p>网络安全通信中要用到两类密码算法，加密一般分为对称加密(Symmetric Key Encryption)和非对称加密(Asymmetric Key Encryption)。对称密码算法有时又叫传统密码算法、秘密密钥算法或单密钥算法，非对称密码算法也叫公开密钥密码算法或双密钥算法。对称密码算法的加密密钥能够从解密密钥中推算出来，反过来也成立。在大多数对称算法中，加密解密密钥是相同的。它要求发送者和接收者在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都能对消息进行加密解密。只要通信需要保密，密钥就必须保密。</p>
</li>
<li><p>对称算法又可分为两类。一次只对明文中的单个位（有时对字节）运算的算法称为序列算法或序列密码。另一类算法是对明文的一组位进行运算，这些位组称为分组，相应的算法称为分组算法或分组密码。现代计算机密码算法的典型分组长度为64位――这个长度既考虑到分析破译密码的难度，又考虑到使用的方便性。后来，随着破译能力的发展，分组长度又提高到128位或更长。</p>
</li>
<li><p>常用的采用对称密码术的加密方案有5个组成部分：</p>
<ul>
<li>1)明文：原始信息。</li>
<li>2)加密算法：以密钥为参数，对明文进行多种置换和转换的规则和步骤，变换结果为密文。</li>
<li>3)密钥：加密与解密算法的参数，直接影响对明文进行变换的结果。</li>
<li>4)密文：对明文进行变换的结果。</li>
<li>5)解密算法：加密算法的逆变换，以密文为输入、密钥为参数，变换结果为明文。</li>
</ul>
</li>
<li><p>分组加密算法中，一般有ECB,CBC,CFB,OFB这几种算法模式。</p>
</li>
</ul>
<h3 id="什么是DES加密"><a href="#什么是DES加密" class="headerlink" title="什么是DES加密"></a>什么是DES加密</h3><ul>
<li><p>DES是Data Encryption Standard（数据加密标准）的缩写。它是由IBM公司研制的一种对称密码算法，美国国家标准局于1977年公布把它作为非机要部门使用的数据加密标准，三十年来，它一直活跃在国际保密通信的舞台上，扮演了十分重要的角色。</p>
</li>
<li><p>DES是一个分组加密算法，典型的DES以64位为分组对数据加密，加密和解密用的是同一个算法。它的密钥长度是56位（因为每个第8 位都用作奇偶校验），密钥可以是任意的56位的数，而且可以任意时候改变。其中有极少数被认为是易破解的弱密钥，但是很容易避开它们不用。所以保密性依赖于密钥。</p>
</li>
<li><p>DES加密的算法框架如下：</p>
<ul>
<li>首先要生成一套加密密钥，从用户处取得一个64位长的密码口令，然后通过等分、移位、选取和迭代形成一套16个加密密钥，分别供每一轮运算中使用。</li>
</ul>
</li>
<li><p>DES解密过程：</p>
<ul>
<li>在了解了加密过程中所有的代替、置换、异或和循环迭代之后，读者也许会认为，解密算法应该是加密的逆运算，与加密算法完全不同。恰恰相反，经过密码学家精心设计选择的各种操作，DES获得了一个非常有用的性质：加密和解密使用相同的算法！</li>
</ul>
</li>
</ul>
<p>加密工作模式：ECB、CBC、CFB、OFB</p>
<ul>
<li><p>ECB   电子密码本模式：Electronic codebook  每块堵路加密 </p>
<ul>
<li><p>优点：分块处理 并行处理</p>
</li>
<li><p>缺点：同样的原文得到相同的密文  容易被攻击</p>
</li>
</ul>
</li>
<li><p>CBC 密码分组链接：Cipher-block chaining  每块加密依赖前一块的密文</p>
<ul>
<li><p>优点：同样的原文得到不同的密文  原文微下的改变影响后面全部密文</p>
</li>
<li><p>缺点：加密需要串行处理  误差传递</p>
</li>
</ul>
</li>
<li><p>CFB Cipher Feedback (CFB)/密文反馈模式</p>
<ul>
<li>密文反馈（CFB，Cipher feedback）模式类似于CBC，可以将块密码变为自同步的流密码；工作过程亦非常相似，CFB的解密过程几乎就是颠倒的CBC的加密过程：需要使用一个与块的大小相同的移位寄存器，并用IV将寄存器初始化。然后，将寄存器内容使用块密码加密，然后将结果的最高x位与平文的x进行异或，以产生密文的x位。下一步将生成的x位密文移入寄存器中，并对下面的x位平文重复这一过程。解密过程与加密过程相似，以IV开始，对寄存器加密，将结果的高x与密文异或，产生x位平文，再将密文的下面x位移入寄存器。</li>
<li>与CBC相似，平文的改变会影响接下来所有的密文，因此加密过程不能并行化；而同样的，与CBC类似，解密过程是可以并行化的。</li>
</ul>
</li>
<li><p>OFB Output Feedback (OFB)/输出反馈模式</p>
<ul>
<li>输出反馈模式（Output feedback, OFB）可以将块密码变成同步的流密码。它产生密钥流的块，然后将其与平文块进行异或，得到密文。与其它流密码一样，密文中一个位的翻转会使平文中同样位置的位也产生翻转。这种特性使得许多错误校正码，例如奇偶校验位，即使在加密前计算而在加密后进行校验也可以得出正确结果。</li>
<li>每个使用OFB的输出块与其前面所有的输出块相关，因此不能并行化处理。然而，由于平文和密文只在最终的异或过程中使用，因此可以事先对IV进行加密，最后并行的将平文或密文进行并行的异或处理。</li>
<li>可以利用输入全0的CBC模式产生OFB模式的密钥流。这种方法十分实用，因为可以利用快速的CBC硬件实现来加速OFB模式的加密过程。</li>
</ul>
</li>
</ul>
<h3 id="什么是3DES加密"><a href="#什么是3DES加密" class="headerlink" title="什么是3DES加密"></a>什么是3DES加密</h3><ul>
<li>3DES，即triple-DES，简单地说就是3次DES加解密的组合。现已不推荐使用。（E表示Encrypt，D表示Decrypt。）</li>
<li>加密：cipthertext = E(k3, D(k2, E(k1, plaintext)))</li>
<li>解密：plaintext = D(k1, E(k2, D(k3, ciphertext)))</li>
<li>特点：如果三个密钥都一样，拿刚好和DES一样。</li>
</ul>
<h3 id="什么是AES加密"><a href="#什么是AES加密" class="headerlink" title="什么是AES加密"></a>什么是AES加密</h3><ul>
<li>AES, Advanced Encryption Standard，是现行的对称加密标准。目前（2017）如果使用对称加密，应该使用AES。当然，只能说当前AES算法是安全的，不能保证AES永远都是安全的。</li>
<li>分组：128bit。</li>
<li>密钥：128bit、192bit、256bit。</li>
<li>Go语言包只支持128bit，因此下例子中使用的是128bit</li>
</ul>
<h3 id="DSA-（Digital-Signature-Algorithm）"><a href="#DSA-（Digital-Signature-Algorithm）" class="headerlink" title="DSA （Digital Signature Algorithm）"></a>DSA （Digital Signature Algorithm）</h3><ul>
<li><p>DSA（Digital Signature Algorithm）是Schnorr和ElGamal签名算法的变种，被美国NIST作为DSS(DigitalSignature Standard)。</p>
</li>
<li><p>DSA加密算法主要依赖于整数有限域离散对数难题，素数P必须足够大，且p-1至少包含一个大素数因子以抵抗Pohlig &amp;Hellman算法的攻击。M一般都应采用信息的HASH值。DSA加密算法的安全性主要依赖于p和g，若选取不当则签名容易伪造，应保证g对于p-1的大素数因子不可约。其安全性与RSA相比差不多。</p>
</li>
<li><p>DSA 一般用于数字签名和认证。在DSA数字签名和认证中，发送者使用自己的私钥对文件或消息进行签名，接受者收到消息后使用发送者的公钥来验证签名的真实性。DSA只是一种算法，和RSA不同之处在于它不能用作加密和解密，也不能进行密钥交换，只用于签名,它比RSA要快很多.</p>
</li>
</ul>
<h3 id="ECC-（Elliptic-Curves-Cryptography），椭圆曲线密码编码学。"><a href="#ECC-（Elliptic-Curves-Cryptography），椭圆曲线密码编码学。" class="headerlink" title="ECC （Elliptic Curves Cryptography），椭圆曲线密码编码学。"></a>ECC （Elliptic Curves Cryptography），椭圆曲线密码编码学。</h3><ul>
<li><p>椭圆曲线密码学（英语：Elliptic curve cryptography，缩写为ECC），一种建立公开密钥加密的算法，基于椭圆曲线数学。椭圆曲线在密码学中的使用是在1985年由Neal Koblitz和Victor Miller分别独立提出的。</p>
</li>
<li><p>椭圆曲线密码学的主要优势是在某些情况下它比其他的方法使用更小的密钥 — — 比如RSA加密算法 — — 提供相当的或更高等级的安全。椭圆曲线密码学的另一个优势是可以定义群之间的双线性映射，基于Weil对或是Tate对；双线性映射已经在密码学中发现了大量的应用，例如基于身份的加密。不过一个缺点是加密和解密操作的实现比其他机制花费的时间长。</p>
</li>
<li><p>椭圆曲线密码学,是一种建立公开密钥加密的算法,也就输非对称加密.类似的还有RSA,EIGamal算法等.ECC被公认为在给定密钥长度下最安全的加密算法.</p>
</li>
</ul>
<p><strong>双线性映射解释：在数论中，一个双线性映射是由两个向量空间上的元素，生成第三个向量空间上一个元素之函数，并且该函数对每个参数都是线性的。</strong></p>
<h3 id="什么是RSA"><a href="#什么是RSA" class="headerlink" title="什么是RSA"></a>什么是RSA</h3><ul>
<li>RSA加密算法是一种非对称加密算法，在公开密钥加密和电子商业中被广泛使用。RSA是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。</li>
</ul>
<ul>
<li>这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。</li>
</ul>
<ul>
<li>RSA算法用到的数学知识<ul>
<li>寻找两个不相同的质数</li>
<li>模运算</li>
<li>互质数,又称互素。若N个整数的最大公因子是1，则称这N个整数互质。</li>
<li>指数运算</li>
<li>同余</li>
<li>根据欧拉函数和欧拉公式</li>
<li>模反元素</li>
</ul>
</li>
</ul>
<h3 id="ECC-和-RSA-相比"><a href="#ECC-和-RSA-相比" class="headerlink" title="ECC 和 RSA 相比"></a>ECC 和 RSA 相比</h3><ul>
<li>抗攻击性强。相同的密钥长度，其抗攻击性要强很多倍。</li>
<li>计算量小，处理速度快。ECC 总的速度比 RSA、DSA 要快得多。</li>
<li>存储空间占用小。ECC 的密钥尺寸和系统参数与 RSA、DSA 相比要小得多，意味着它所占的存贮空间要小得多。这对于加密算法在 IC 卡上的应用具有特别重要的意义。</li>
<li>带宽要求低。当对长消息进行加解密时，三类密码系统有相同的带宽要求，但应用于短消息时 ECC 带宽要求却低得多。带宽要求低使 ECC 在无线网络领域具有广泛的应用前景。</li>
</ul>
<h3 id="什么是非对称加密"><a href="#什么是非对称加密" class="headerlink" title="什么是非对称加密"></a>什么是非对称加密</h3><p>公开密钥加密（英语：public-key cryptography，又译为公开密钥加密），也称为非对称加密（asymmetric cryptography），一种密码学算法类型，在这种密码学方法中，需要一对密钥(其实这里密钥说法不好，就是“钥”)，一个是私人密钥，另一个则是公开密钥。这两个密钥是数学相关，用某用户密钥加密后所得的信息，只能用该用户的解密密钥才能解密。如果知道了其中一个，并不能计算出另外一个。因此如果公开了一对密钥中的一个，并不会危害到另外一个的秘密性质。称公开的密钥为公钥；不公开的密钥为私钥。–wiki百科</p>
<ul>
<li>指的是加、解密使用不同的密钥，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才能解密。反之，私钥加密的信息，只有公钥才能解密。俗话来说：“要想使用非对称加密算法，首先要有一对key，一个被称为private key私钥，一个成为public key公钥，然后可以把你的public key分发给想给你传密文的用户，然后用户使用该public key加密过得密文，只有使用你的private key才能解密，也就是说，只要你自己保存好你的private key，就能确保，别人想给你发的密文不被破解，所以你不用担心别人的密钥被盗，没关系。 ”</li>
</ul>
<h3 id="Hash-算法"><a href="#Hash-算法" class="headerlink" title="Hash 算法"></a>Hash 算法</h3><ul>
<li>Hash 算法特别的地方在于它是一种单向算法，用户可以通过 Hash 算法对目标信息生成一段特定长度的唯一的 Hash 值，却不能通过这个 Hash 值重新获得目标信息。因此 Hash 算法常用在不可还原的密码存储、信息完整性校验等。</li>
</ul>
<ul>
<li><p>单向散列函数一般用于产生消息摘要，密钥加密等，常见的有：</p>
<ul>
<li>MD5 （Message Digest Algorithm 5）：是 RSA 数据安全公司开发的一种单向散列算法，非可逆，相同的明文产生相同的密文；</li>
<li>SHA （Secure Hash Algorithm）：可以对任意长度的数据运算生成一个 160 位的数值。</li>
</ul>
</li>
<li><p>SHA-1 与 MD5 的比较 :</p>
<ul>
<li><p>因为二者均由 MD4 导出，SHA-1 和 MD5 彼此很相似。相应的，他们的强度和其他特性也是相似，但还有以下几点不同：</p>
</li>
<li><p>对强行供给的安全性：最显著和最重要的区别是 SHA-1 摘要比 MD5 摘要长 32 位。使用强行技术，产生任何一个报文使其摘要等于给定报摘要的难度对 MD5 是 2128 数量级的操作，而对 SHA-1 则是 2160 数量级的操作。这样，SHA-1 对强行攻击有更大的强度；</p>
</li>
<li>对密码分析的安全性：由于 MD5 的设计，易受密码分析的攻击，SHA-1 显得不易受这样的攻击；</li>
<li>速度：在相同的硬件上，SHA-1 的运行速度比 MD5 慢。</li>
</ul>
</li>
</ul>
<h3 id="对称加密与非对称加密对比"><a href="#对称加密与非对称加密对比" class="headerlink" title="对称加密与非对称加密对比"></a>对称加密与非对称加密对比</h3><ul>
<li><p>在管理方面：公钥密码算法只需要较少的资源就可以实现目的，在密钥的分配上，两者之间相差一个指数级别（一个是 n 一个是 n2）。所以私钥密码算法不适应广域网的使用，而且更重要的一点是它不支持数字签名；</p>
</li>
<li><p>在安全方面：由于公钥密码算法基于未解决的数学难题，在破解上几乎不可能。对于私钥密码算法，到了 AES 虽说从理论来说是不可能破解的，但从计算机的发展角度来看。公钥更具有优越性；</p>
</li>
<li><p>从速度上来看：AES 的软件实现速度已经达到了每秒数兆或数十兆比特。是公钥的 100 倍，如果用硬件来实现的话这个比值将扩大到 1000 倍。</p>
</li>
<li><p>对称加密优缺点：对称加密相比非对称加密算法来说，加解密的效率要高得多、加密速度快。但是缺陷在于对于密钥的管理和分发上比较困难，不是非常安全，密钥管理负担很重。</p>
</li>
<li><p>非对称加密优缺点：安全性更高，公钥是公开的，密钥是自己保存的，不需要将私钥给别人。缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</p>
</li>
</ul>
<h3 id="DES、3DES、AES、RSA（非对称加密）Go语言实现"><a href="#DES、3DES、AES、RSA（非对称加密）Go语言实现" class="headerlink" title="DES、3DES、AES、RSA（非对称加密）Go语言实现"></a>DES、3DES、AES、RSA（非对称加密）Go语言实现</h3><p>代码托管已上传到Github，请访问连接查看：<a href="https://github.com/chuhemiao/myCrypto" target="_blank" rel="external">Go语言实现加密算法</a></p>
<h3 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h3><ul>
<li>非对称加密安全，但是效率比较慢，对称加密效率高，但是不安全。</li>
<li>一般来说，密钥越长，运行的速度就越慢，应该根据的我们实际需要的安全级别来选择，一般来说，RSA 建议采用 1024 位的数字，ECC 建议采用 160 位，AES 采用 128 为即可。</li>
</ul>
<p>参考：</p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86" target="_blank" rel="external">wiki百科-公开密钥加密</a></p>
<p><a href="https://github.com/xr/xr.github.io/issues/3" target="_blank" rel="external">白话-对称加密算法 vs 非对称加密算法</a></p>
<p><a href="https://www.jianshu.com/p/b63095c59361" target="_blank" rel="external">对称加密算法和分组密码的模式</a></p>
<p><a href="https://www.chainnews.com/articles/222021126804.htm" target="_blank" rel="external">一文读懂对称加密算法、非对称加密算法和 Hash 算法</a></p>
<p><a href="https://juejin.im/post/5d2ae58f51882548ea35b9b0" target="_blank" rel="external">ECC椭圆曲线加密算法</a></p>
<p><a href="https://blog.damonare.cn/2017/12/31/RSA%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/#more" target="_blank" rel="external">RSA算法详解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;加密算法导读&quot;&gt;&lt;a href=&quot;#加密算法导读&quot; class=&quot;headerlink&quot; title=&quot;加密算法导读&quot;&gt;&lt;/a&gt;加密算法导读&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;加密一般分为对称加密(Symmetric Key Encryption)和非对称加密(As
    
    </summary>
    
      <category term="blockchain" scheme="http://idiot6.com/categories/blockchain/"/>
    
    
      <category term="golang" scheme="http://idiot6.com/tags/golang/"/>
    
      <category term="aes" scheme="http://idiot6.com/tags/aes/"/>
    
      <category term="des" scheme="http://idiot6.com/tags/des/"/>
    
      <category term="3des" scheme="http://idiot6.com/tags/3des/"/>
    
  </entry>
  
  <entry>
    <title>type annotations can only be used in typescript files.ts(8010)</title>
    <link href="http://idiot6.com/2020/05/23/type%20annotations%20can%20only%20be%20used%20in%20typescript%20files.ts(8010)/"/>
    <id>http://idiot6.com/2020/05/23/type annotations can only be used in typescript files.ts(8010)/</id>
    <published>2020-05-23T09:03:53.000Z</published>
    <updated>2020-07-19T08:26:58.594Z</updated>
    
    <content type="html"><![CDATA[<h3 id="配置VS配置文件"><a href="#配置VS配置文件" class="headerlink" title="配置VS配置文件"></a>配置VS配置文件</h3><ul>
<li>macos，preference=》setting=〉搜索 settings.json 点击Edit in settings.json</li>
<li>添加配置 <ul>
<li>“javascript.validate.enable”: false </li>
<li>“typescript.validate.enable”: false,</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;配置VS配置文件&quot;&gt;&lt;a href=&quot;#配置VS配置文件&quot; class=&quot;headerlink&quot; title=&quot;配置VS配置文件&quot;&gt;&lt;/a&gt;配置VS配置文件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;macos，preference=》setting=〉搜索 settings.j
    
    </summary>
    
      <category term="vscode" scheme="http://idiot6.com/categories/vscode/"/>
    
    
      <category term="vscode" scheme="http://idiot6.com/tags/vscode/"/>
    
      <category term="typescript" scheme="http://idiot6.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>2020年Macos最全ETH区块链环境搭建,并使用Truffle创建第一个Dapps</title>
    <link href="http://idiot6.com/2020/04/19/%202020%E5%B9%B4Macos%E6%9C%80%E5%85%A8%20ETH%E5%8C%BA%E5%9D%97%E9%93%BE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA,%E5%B9%B6%E4%BD%BF%E7%94%A8Truffle%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AADapps/"/>
    <id>http://idiot6.com/2020/04/19/ 2020年Macos最全 ETH区块链环境搭建,并使用Truffle创建第一个Dapps/</id>
    <published>2020-04-19T15:23:53.000Z</published>
    <updated>2020-07-19T08:26:58.003Z</updated>
    
    <content type="html"><![CDATA[<h3 id="以太坊开需要哪些工具"><a href="#以太坊开需要哪些工具" class="headerlink" title="以太坊开需要哪些工具"></a>以太坊开需要哪些工具</h3><ul>
<li><p>HomeBrew</p>
</li>
<li><p>Xcode命令行工具</p>
</li>
<li><p>go-ethereum</p>
</li>
<li><p>Ganache</p>
</li>
<li><p>nodejs和npm</p>
</li>
<li><p>Truffle</p>
</li>
<li><p>VsCode</p>
</li>
</ul>
<h3 id="安装HOMEBREW"><a href="#安装HOMEBREW" class="headerlink" title="安装HOMEBREW"></a>安装HOMEBREW</h3><ul>
<li><p>如果已经安装请忽略本步骤</p>
</li>
<li><p>请打开<a href="https://brew.sh/，然后复制红框内内容" target="_blank" rel="external">https://brew.sh/，然后复制红框内内容</a>: <code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></p>
</li>
</ul>
<p><img src="https://cdn.bsatoshi.com/2019/12/14/15763112879761.jpg" alt="homebrew"></p>
<h3 id="安装Xcode"><a href="#安装Xcode" class="headerlink" title="安装Xcode"></a>安装Xcode</h3><ul>
<li>一般电脑应该会有，没有的话，那自行谷歌把！</li>
</ul>
<h3 id="安装geth"><a href="#安装geth" class="headerlink" title="安装geth"></a>安装geth</h3><ul>
<li>brew tap ethereum/ethereum</li>
<li><p>brew install ethereum</p>
</li>
<li><p>检测是否安装完成：输入geth -h，如果出现下图所示，则代表已经安装完成</p>
</li>
</ul>
<h3 id="nodejs和npm"><a href="#nodejs和npm" class="headerlink" title="nodejs和npm"></a>nodejs和npm</h3><ul>
<li><p>brew install node</p>
</li>
<li><p>node -v 检测是否已经安装成功</p>
</li>
<li><p>npm -v</p>
</li>
</ul>
<h3 id="安装truffle"><a href="#安装truffle" class="headerlink" title="安装truffle"></a>安装truffle</h3><ul>
<li><p>npm install -g truffle</p>
</li>
<li><p>truffle -v 检测是否安装成功</p>
</li>
</ul>
<h3 id="安装Ganache"><a href="#安装Ganache" class="headerlink" title="安装Ganache"></a>安装Ganache</h3><ul>
<li><p>浏览器中打开下面的链接，<a href="https://www.trufflesuite.com/ganache" target="_blank" rel="external">https://www.trufflesuite.com/ganache</a></p>
</li>
<li><p>下载Ganache for MacOS ，然后点击下载后的dmg包，依次按步骤执行即可。</p>
</li>
<li><p>然后启动此软件，就可以进行相关调试了，如下图</p>
</li>
</ul>
<p><img src="https://cdn.bsatoshi.com/2019/12/14/15763116506866.jpg" alt="安装Ganache"></p>
<h3 id="安装VsCode"><a href="#安装VsCode" class="headerlink" title="安装VsCode"></a>安装VsCode</h3><ul>
<li><p>打开网页：<a href="https://code.visualstudio.com/，下载后直接打开。" target="_blank" rel="external">https://code.visualstudio.com/，下载后直接打开。</a></p>
</li>
<li><p>然后安装插件，先点击步骤1，然后在步骤上直接搜索当前要安装的插件名称，然后点击install即可</p>
</li>
</ul>
<p><img src="https://cdn.bsatoshi.com/2019/12/14/15763119152803.jpg" alt="安装VsCode"></p>
<h3 id="创建第一个dapp"><a href="#创建第一个dapp" class="headerlink" title="创建第一个dapp"></a>创建第一个dapp</h3><ul>
<li><p>首先上述软件已经安装成功，然后打开Ganache客户端，可以看到已经分配的测试网账户和一些余额。</p>
</li>
<li><p>然后打开终端，创建一个目录mkdir blockchain-test</p>
</li>
<li>cd blockchain-test</li>
<li><p>使用前面安装的truffle创建项目，这里推荐使用truffle box 模式，它会带一些自动的事例，具体可以看文档和一些已经存在的项目：<a href="https://www.trufflesuite.com/boxes" target="_blank" rel="external">https://www.trufflesuite.com/boxes</a></p>
</li>
<li><p>这里我们以<a href="https://www.trufflesuite.com/boxes/pet-shop" target="_blank" rel="external">pet-shop</a>,首先执行：sudo truffle unbox pet-shop</p>
</li>
</ul>
<p><img src="https://cdn.bsatoshi.com/2019/12/14/15763125307985.jpg" alt="创建第一个dapp"></p>
<ul>
<li>然后得到新项目目录如下</li>
</ul>
<p><img src="https://cdn.bsatoshi.com/2019/12/14/15763126268873.jpg" alt="创建第一个dapp"></p>
<ul>
<li><p>contracts/ : 包含所有項目中智能合約 Solidity 代码，其中有事例 Migrations.sol 智能合約，容后再介紹；</p>
</li>
<li><p>migrations/ : 主要是 Truffle 用与部署智能合約的一个迁移命令集；</p>
</li>
<li><p>test/ : 包含 JavaScript 和 Solidity 的 test cases；</p>
</li>
<li><p>truffle-config.js : Truffle 的一些设置，比如端口、测试网、正式网等；</p>
</li>
<li><p>node_modules ： 是一些安装的基础包</p>
</li>
<li><p>bs-config.json:是智能合约的编译鲁姆</p>
</li>
<li><p>src：是项目的主入口文件</p>
</li>
<li><p>然后分别依次执行 ： </p>
<ul>
<li>truffle compile</li>
<li>truffle migrate</li>
<li>truffle test</li>
<li>npm run dev</li>
</ul>
</li>
<li><p>然后就可以看到程序已经跑起来：</p>
</li>
</ul>
<p><img src="https://cdn.bsatoshi.com/2019/12/14/15763132463521.jpg" alt="truffle创建第一个dapp"></p>
<ul>
<li>然后程序会默认打开浏览器，也可以直接访问：<a href="http://localhost:3000" target="_blank" rel="external">http://localhost:3000</a> 查看已经得到的效果</li>
</ul>
<p><img src="https://cdn.bsatoshi.com/2019/12/14/15763132695654.jpg" alt="truffle创建第一个dapp"></p>
<ul>
<li>访问：<a href="http://localhost:3001可以看到智能合约的一些交互和当前dapp的一些运行情况，如下图：" target="_blank" rel="external">http://localhost:3001可以看到智能合约的一些交互和当前dapp的一些运行情况，如下图：</a></li>
</ul>
<p><img src="https://cdn.bsatoshi.com/2019/12/14/15763134408246.jpg" alt="truffle创建第一个dapp"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;以太坊开需要哪些工具&quot;&gt;&lt;a href=&quot;#以太坊开需要哪些工具&quot; class=&quot;headerlink&quot; title=&quot;以太坊开需要哪些工具&quot;&gt;&lt;/a&gt;以太坊开需要哪些工具&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;HomeBrew&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Xco
    
    </summary>
    
      <category term="flutter" scheme="http://idiot6.com/categories/flutter/"/>
    
    
      <category term="dart" scheme="http://idiot6.com/tags/dart/"/>
    
      <category term="eth" scheme="http://idiot6.com/tags/eth/"/>
    
      <category term="React native" scheme="http://idiot6.com/tags/React-native/"/>
    
      <category term="Truffle" scheme="http://idiot6.com/tags/Truffle/"/>
    
      <category term="dapps" scheme="http://idiot6.com/tags/dapps/"/>
    
  </entry>
  
  <entry>
    <title>2020最新Macos eos区块链环境搭建和开发教程</title>
    <link href="http://idiot6.com/2020/03/29/%202020%E6%9C%80%E6%96%B0Macos%20eos%E5%8C%BA%E5%9D%97%E9%93%BE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/"/>
    <id>http://idiot6.com/2020/03/29/ 2020最新Macos eos区块链环境搭建和开发教程/</id>
    <published>2020-03-29T14:22:22.000Z</published>
    <updated>2020-07-19T08:26:58.003Z</updated>
    
    <content type="html"><![CDATA[<p><strong>EOS、EOS-Mainnet、EOSIO都是什么？</strong></p>
<h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><ul>
<li><p>2017年，一个叫Block.one的公司开发了一个叫EOSIO的软件。为了开发这个软件，Block.one进行了一个历时350天的众筹，最后募集资金超过40亿美元。</p>
</li>
<li><p>EOSIO这个软件是后来的EOS-Mainnet和其他区块链网络（BOS、Telos等等）构建网络的基础工具。</p>
</li>
<li><p>EOS-Mainnet，也就是EOS主网，是我们目前使用最广泛的基于EOSIO软件的区块链网络。网上听说的很多EOS Dapp（Decentralized Application，去中心化的app）都是运行在EOS主网上，大多数人一说EOS，基本上指的就是EOS主网。</p>
</li>
<li><p>EOS是EOS主网上的原生代币的符号，EOS的数量体现了你在EOS主网上可使用资源和可参与治理的多少。EOS本身具有价格，可以在各大交易所购买。</p>
</li>
</ul>
<h3 id="账户、公钥、私钥"><a href="#账户、公钥、私钥" class="headerlink" title="账户、公钥、私钥"></a>账户、公钥、私钥</h3><ul>
<li><p>在EOS上，账户类似于用户名，所有的操作都是以账户为基础的，转账、投票、更新信息，参与Dapp等等。账户需要注册，至多12位字符。</p>
</li>
<li><p>如何证明这个账户是属于你的而不是别人的呢？这个就需要用到公钥和私钥，用互联网来类比的话就是密码，不过这个密码是由公钥和私钥两部分构成的。<br>形象地理解，公钥和私钥就相当于锁和钥匙，私钥，也就是钥匙，掌握在你自己手里；公钥，也就是锁，和账户绑定。如果你想在账户里进行操作，就需要用你手里的私钥和公钥匹配，如果匹配上了，那么账户就认为你是所有者。</p>
</li>
<li><p>实际上，EOS的账户系统还可以更加复杂，比如给予每个公钥/私钥对不同的权限（Owner和Active），对一个账户就行多人共管（Multi-sig，多签）等等，暂时先不展开了。<br>注意，一个公钥/私钥对可以同时控制多个账户。</p>
</li>
</ul>
<p>（三）钱包</p>
<ul>
<li><p>常用的钱包，PC端和国外主要用Scatter，手机端和国内主要用TokenPocket、Meetone。这些可以通过他们的官网下载。</p>
</li>
<li><p>每个EOS账户里面存在着三者资源，所有的操作都需要花费这三种资源，可以理解，这三种资源是你使用EOS网络的成本。这三种资源叫做计算（CPU）、存储（RAM）和网络（NET）。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>项目</th>
<th>传统含义</th>
<th>EOS上含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>计算（CPU）</td>
<td>中央处理单元，指的是负责在计算机中执行指令和处理信息的硬件</td>
<td>一种按时间计价的资源（单位：微秒），用来衡量EOS节点应该对你帐户中的交易确认所投入的时间</td>
</tr>
<tr>
<td>网络（NET）</td>
<td>互联网带宽</td>
<td>一种以空间计价的资源（单位：字节），用来衡量当在P2P层上传输数据时需要多少区块的网络描述来存储你的交易数据</td>
</tr>
<tr>
<td>存储（RAM）</td>
<td>存储是用来存储云平台上的所有数据。RAM是指运行内存，速度更快，但储存是暂时的，断电后内容就会消失</td>
<td>RAM不再是临时存储，而是作为主储存层，用来储存所有的数据。相当于是让储存速度更快的内存（RAM）充当了硬盘的功能。在RAM中存储数据库，可以让读取数据的速度更快</td>
</tr>
</tbody>
</table>
<h3 id="EOSIO如何快速构建开发网络"><a href="#EOSIO如何快速构建开发网络" class="headerlink" title="EOSIO如何快速构建开发网络"></a>EOSIO如何快速构建开发网络</h3><ul>
<li>EOSIO是由三个组件组成的。<ul>
<li>nodeos:管理区块链节点的组件。</li>
<li>keosd：管理钱包的组件。</li>
<li>cleos：控制区块链和钱包CLI工具。</li>
</ul>
</li>
</ul>
<h3 id="Macos-安装EOSIO"><a href="#Macos-安装EOSIO" class="headerlink" title="Macos 安装EOSIO"></a>Macos 安装EOSIO</h3><ul>
<li><p>安装  <code>brew tap eosio/eosio</code>   <code>brew install eosio</code></p>
</li>
<li><p>卸载 <code>brew remove eosio</code></p>
</li>
</ul>
<h3 id="Ubuntu-18-04-Debian-安装-eosio"><a href="#Ubuntu-18-04-Debian-安装-eosio" class="headerlink" title="Ubuntu 18.04  Debian 安装 eosio"></a>Ubuntu 18.04  Debian 安装 eosio</h3><ul>
<li><p>wget <a href="https://github.com/EOSIO/eos/releases/download/v1.8.6/eosio_1.8.6-1-ubuntu-18.04_amd64.deb" target="_blank" rel="external">https://github.com/EOSIO/eos/releases/download/v1.8.6/eosio_1.8.6-1-ubuntu-18.04_amd64.deb</a></p>
</li>
<li><p>sudo apt install ./eosio_1.8.6-1-ubuntu-18.04_amd64.deb</p>
</li>
</ul>
<h3 id="Ubuntu-16-04-Debian-安装-eosio"><a href="#Ubuntu-16-04-Debian-安装-eosio" class="headerlink" title="Ubuntu 16.04 Debian 安装 eosio"></a>Ubuntu 16.04 Debian 安装 eosio</h3><ul>
<li><p>wget <a href="https://github.com/EOSIO/eos/releases/download/v1.8.6/eosio_1.8.6-1-ubuntu-16.04_amd64.deb" target="_blank" rel="external">https://github.com/EOSIO/eos/releases/download/v1.8.6/eosio_1.8.6-1-ubuntu-16.04_amd64.deb</a></p>
</li>
<li><p>sudo apt install ./eosio_1.8.6-1-ubuntu-18.04_amd64.deb</p>
</li>
</ul>
<h3 id="CentOS-通过RPM-安装-eosio"><a href="#CentOS-通过RPM-安装-eosio" class="headerlink" title="CentOS 通过RPM  安装 eosio"></a>CentOS 通过RPM  安装 eosio</h3><ul>
<li><p>wget <a href="https://github.com/EOSIO/eos/releases/download/v1.8.6/eosio-1.8.6-1.el7.x86_64.rpm" target="_blank" rel="external">https://github.com/EOSIO/eos/releases/download/v1.8.6/eosio-1.8.6-1.el7.x86_64.rpm</a></p>
</li>
<li><p>sudo yum install ./eosio-1.8.6-1.el7.x86_64.rpm</p>
</li>
</ul>
<h3 id="设置一个开发目录"><a href="#设置一个开发目录" class="headerlink" title="设置一个开发目录"></a>设置一个开发目录</h3><ul>
<li><p>cd /data  mkdir development-eos</p>
</li>
<li><p>cd development-eos  进入开发目录</p>
</li>
</ul>
<h3 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h3><ul>
<li><p>keosd &amp;</p>
</li>
<li><p>如果成功则会看到如下截图：</p>
</li>
</ul>
<p><img src="https://cdn.bsatoshi.com/2019/12/14/15763095080716.jpg" alt="keosd"></p>
<h3 id="启动nodeos"><a href="#启动nodeos" class="headerlink" title="启动nodeos"></a>启动nodeos</h3><pre><code>nodeos -e -p eosio \
--plugin eosio::producer_plugin \
--plugin eosio::chain_api_plugin \
--plugin eosio::http_plugin \
--plugin eosio::history_plugin \
--plugin eosio::history_api_plugin \
--filter-on=&quot;*&quot; \
--access-control-allow-origin=&apos;*&apos; \
--contracts-console \
--http-validate-host=false \
--verbose-http-errors &gt;&gt; nodeos.log 2&gt;&amp;1 &amp;
</code></pre><h3 id="查看nodeos-log是否已经启动nodeos"><a href="#查看nodeos-log是否已经启动nodeos" class="headerlink" title="查看nodeos.log是否已经启动nodeos"></a>查看nodeos.log是否已经启动nodeos</h3><ul>
<li>tail -f nodeos.log</li>
</ul>
<p><img src="https://cdn.bsatoshi.com/2019/12/14/15763097186602.jpg" alt="nodeos.log"></p>
<h3 id="查看当前已经存在的eos钱包"><a href="#查看当前已经存在的eos钱包" class="headerlink" title="查看当前已经存在的eos钱包"></a>查看当前已经存在的eos钱包</h3><ul>
<li><p>cleos wallet list</p>
</li>
<li><p>不出意外应该会返回一个空的数组，当前我们并没有创建钱包</p>
</li>
</ul>
<h3 id="检查Nodeos-的端口"><a href="#检查Nodeos-的端口" class="headerlink" title="检查Nodeos 的端口"></a>检查Nodeos 的端口</h3><ul>
<li>浏览器打开：<a href="http://localhost:8888/v1/chain/get_info" target="_blank" rel="external">http://localhost:8888/v1/chain/get_info</a>  当然你也可以直接使用curl的方式：curl <a href="http://localhost:8888/v1/chain/get_info" target="_blank" rel="external">http://localhost:8888/v1/chain/get_info</a></li>
</ul>
<p><img src="https://cdn.bsatoshi.com/2019/12/14/15763099467987.jpg" alt="检查Nodeos 的端口"></p>
<h3 id="Macos安装CDT"><a href="#Macos安装CDT" class="headerlink" title="Macos安装CDT"></a>Macos安装CDT</h3><ul>
<li>brew tap eosio/eosio.cdt</li>
<li><p>brew install eosio.cdt</p>
</li>
<li><p>卸载CDT  brew remove eosio.cdt</p>
</li>
</ul>
<h3 id="CentOS-Redhat内核安装CDT"><a href="#CentOS-Redhat内核安装CDT" class="headerlink" title="CentOS/Redhat内核安装CDT"></a>CentOS/Redhat内核安装CDT</h3><ul>
<li><p>wget <a href="https://github.com/EOSIO/eosio.cdt/releases/download/v1.6.3/eosio.cdt-1.6.3-1.el7.x86_64.rpm" target="_blank" rel="external">https://github.com/EOSIO/eosio.cdt/releases/download/v1.6.3/eosio.cdt-1.6.3-1.el7.x86_64.rpm</a></p>
</li>
<li><p>sudo yum install ./eosio.cdt-1.6.3-1.el7.x86_64.rpm</p>
</li>
<li><p>卸载CDT   sudo yum remove eosio.cdt</p>
</li>
</ul>
<h3 id="通过源码编译方式安装CDT"><a href="#通过源码编译方式安装CDT" class="headerlink" title="通过源码编译方式安装CDT"></a>通过源码编译方式安装CDT</h3><ul>
<li>首先克隆下源码 git clone –recursive <a href="https://github.com/eosio/eosio.cdt" target="_blank" rel="external">https://github.com/eosio/eosio.cdt</a> –branch v1.6.3 –single-branch</li>
</ul>
<ul>
<li><p>然后执行 cd eosio.cdt   ./build.sh</p>
</li>
<li><p>sudo ./install.sh</p>
</li>
</ul>
<h3 id="创建一个开发模式的钱包"><a href="#创建一个开发模式的钱包" class="headerlink" title="创建一个开发模式的钱包"></a>创建一个开发模式的钱包</h3><ul>
<li><p>首先执行创建钱包的命令：cleos wallet create –to-console  ， 此时cleos会返回一个密码，你可以存在任何地方，后续以备使用。</p>
</li>
<li><p>打开一个eos钱包：cleos wallet open</p>
</li>
<li><p>返回钱包的列表查看目前可以打开的钱包：cleos wallet list</p>
</li>
<li><p>打开之前首先需要解锁：cleos wallet unlock</p>
</li>
<li><p>然后在输入：cleos wallet list，会看到列表的钱包后面会增加一个*号，然后就可以在执行打开命令打开。</p>
</li>
</ul>
<h3 id="生成带有密钥的EOS钱包"><a href="#生成带有密钥的EOS钱包" class="headerlink" title="生成带有密钥的EOS钱包"></a>生成带有密钥的EOS钱包</h3><ul>
<li>cleos wallet create_key</li>
<li><p>运行上述命令后会得到一个新的key： “EOS8PEJ5FM4LLLpHK…X6PypHu97kqGDJQY5Y”</p>
</li>
<li><p>在网页<a href="https://developers.eos.io/eosio-home/docs/wallets" target="_blank" rel="external">https://developers.eos.io/eosio-home/docs/wallets</a> 的第五步输入上述得到的key就可以得到一个开发的Public key</p>
</li>
</ul>
<h3 id="导出开发的密钥"><a href="#导出开发的密钥" class="headerlink" title="导出开发的密钥"></a>导出开发的密钥</h3><ul>
<li>cleos wallet import，运行命令后会得到一串字符串（private key），包存后可以用来后期的开发</li>
</ul>
<h3 id="创建eos测试账户"><a href="#创建eos测试账户" class="headerlink" title="创建eos测试账户"></a>创建eos测试账户</h3><ul>
<li><p>使用命令分别创建bob和alice两个账户，YOUR_PUBLIC_KEY是之前步骤生成的key</p>
</li>
<li><p>cleos create account eosio bob YOUR_PUBLIC_KEY </p>
</li>
<li><p>cleos create account eosio alice YOUR_PUBLIC_KEY</p>
</li>
<li><p>运行命令后会反馈当前广播交易的消息</p>
</li>
</ul>
<h3 id="获取Public-Key"><a href="#获取Public-Key" class="headerlink" title="获取Public Key"></a>获取Public Key</h3><ul>
<li>cleos get account alice（当前创建的用户）</li>
</ul>
<p><img src="https://cdn.bsatoshi.com/2019/12/14/15763107114594.jpg" alt="获取Public Key"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://developers.eos.io/eosio-home/docs/setting-up-your-environment" target="_blank" rel="external">developers eos</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;EOS、EOS-Mainnet、EOSIO都是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;20
    
    </summary>
    
      <category term="flutter" scheme="http://idiot6.com/categories/flutter/"/>
    
    
      <category term="dart" scheme="http://idiot6.com/tags/dart/"/>
    
      <category term="eth" scheme="http://idiot6.com/tags/eth/"/>
    
      <category term="React native" scheme="http://idiot6.com/tags/React-native/"/>
    
      <category term="Truffle" scheme="http://idiot6.com/tags/Truffle/"/>
    
      <category term="dapps" scheme="http://idiot6.com/tags/dapps/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言解决不能Go get安装Gin问题解决方案</title>
    <link href="http://idiot6.com/2019/07/23/go-gin-golang-x/"/>
    <id>http://idiot6.com/2019/07/23/go-gin-golang-x/</id>
    <published>2019-07-23T09:03:53.000Z</published>
    <updated>2020-04-07T16:41:29.008Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Go get 出现超时问题：“golang unrecognized import path &quot;golang.org/x/net   unrecognized import path &quot;golang.org/x/sys&quot;  Unknown SSL protocol error in connection to gopkg.in:443 &quot;”</div></pre></td></tr></table></figure>
<h3 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2.解决办法"></a>2.解决办法</h3><ul>
<li>网络上解决方案1手动下载：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir $GOPATH/src/golang.org/x</div><div class="line">cd $GOPATH/src/golang.org/x</div><div class="line">git clone git@github.com:golang/text.git</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="方案二：设置代理"><a href="#方案二：设置代理" class="headerlink" title="方案二：设置代理"></a>方案二：设置代理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export http_proxy=https://proxyAddress:port</div><div class="line">export https_proxy=https://proxyAddress:port</div></pre></td></tr></table></figure>
<h3 id="3-最佳解决方案"><a href="#3-最佳解决方案" class="headerlink" title="3.最佳解决方案"></a>3.最佳解决方案</h3><ul>
<li><p>从 Go 1.11 版本开始已经开始支持Go Mod ，并且提供了包下载的解决方案，就是使用 <a href="https://goproxy.io/" target="_blank" rel="external">https://goproxy.io/</a> 直接代理下载，官方设置方法：</p>
</li>
<li><p>macos/linux  </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export GO111MODULE=on </div><div class="line">export GOPROXY=https://goproxy.io</div></pre></td></tr></table></figure>
<ul>
<li>Wins 使用PowerShell 设置（这里输入是去当前设置的GOPATH）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$env:GO111MODULE=&quot;on&quot;</div><div class="line">$env:GOPROXY=&quot;https://goproxy.io&quot;</div></pre></td></tr></table></figure>
<p><img src="https://cdn.bsatoshi.com/2019/07/23/72B1D829-1628-4CC9-8129-053951E159C2.png" alt="go-gin-golang"></p>
<ul>
<li>提示这里需要加入引号，否则会报on或地址有问题，之后在执行Go get 等其他命令都一帆风顺了。</li>
</ul>
<h3 id="Notice：-如果你使用的Go-version-》-1-13-请使用"><a href="#Notice：-如果你使用的Go-version-》-1-13-请使用" class="headerlink" title="Notice： 如果你使用的Go version 》=1.13  请使用"></a>Notice： 如果你使用的Go version 》=1.13  请使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">go env -w GOPROXY=https://goproxy.io,direct</div><div class="line">go env -w GOPRIVATE=*.corp.example.com</div></pre></td></tr></table></figure>
<p>Go 成功安装Gin框架并使用Go mod管理</p>
<p><img src="https://cdn.bsatoshi.com/2019/07/23/1C3E1CAC-D142-49F0-95C8-5243B1EB701C.png" alt="安装Gin框架并使用Go"></p>
<p>参考资料：<br><a href="https://goproxy.io/" target="_blank" rel="external">https://goproxy.io/</a><br><a href="https://segmentfault.com/a/1190000018264719" target="_blank" rel="external">一键解决 go get golang.org/x 包失败</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-问题描述&quot;&gt;&lt;a href=&quot;#1-问题描述&quot; class=&quot;headerlink&quot; title=&quot;1.问题描述&quot;&gt;&lt;/a&gt;1.问题描述&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
    
    </summary>
    
      <category term="GO" scheme="http://idiot6.com/categories/GO/"/>
    
    
      <category term="golang" scheme="http://idiot6.com/tags/golang/"/>
    
      <category term="gin" scheme="http://idiot6.com/tags/gin/"/>
    
      <category term="echo" scheme="http://idiot6.com/tags/echo/"/>
    
      <category term="goproxy" scheme="http://idiot6.com/tags/goproxy/"/>
    
  </entry>
  
  <entry>
    <title>2019这个转折年投资风向标应该是A股、币圈还是房地产，你会选哪个？</title>
    <link href="http://idiot6.com/2019/04/10/blockchain_ticker/"/>
    <id>http://idiot6.com/2019/04/10/blockchain_ticker/</id>
    <published>2019-04-10T11:22:27.000Z</published>
    <updated>2019-04-10T11:30:59.868Z</updated>
    
    <content type="html"><![CDATA[<p>城市安放不了躯体</p>
<p>故乡安放不了灵魂</p>
<p>大家好，我是币聪（比特B小白）–詹强威</p>
<p>每天码字的非专业程序员，每晚不定点（21:50）为你罗列B圈那些事</p>
<p>认真写作第 18 天 </p>
<p><img src="https://cdn.bsatoshi.com/2019/02/26/15422863789126.jpg" alt="2019投资风向标"></p>
<p>投资理财是指投资者通过合理安排资金，运用诸如储蓄、银行理财产品、债券、基金、股票、期货、外汇、房地产、保险以及黄金等投资理财工具对个人、家庭和企事业单位资产进行管理和分配，达到保值增值的目的，从而加速资产的增长。</p>
<p>投资理财不等于简单的攒钱、存钱，把钱放在银行里，也不等于简单的炒股(股票买卖)。投资理财是根据需求和目的将所有财产和负债，其中包括有形的、无形的、流动的、非流动的、过去的、现在的、未来的、遗产、遗嘱及知识产权等在内的所有资产和负债进行积极主动的策划、安排、置换、重组等使其达到保值、增值的综合的、系统的、全面的经济活动。前者只是投资的一种具体行为，充其量为现金的使用。作为投资理财一部分的现金管理要比它复杂得多，也难得多。–自MBA智库</p>
<p>国内很多人都说：“富不过三代”，其实是有原因的，不注重理财和资产管理，只会慢慢走向衰落，因此理财对于千禧一代或许是新的机会，可以选择基金、股票、数字币…</p>
<p>改革开放40年来，已经早就了很多很多的已经成功的人士，而也给千禧一代带来了巨大的压力，90后、00后已经成为了不敢生、不敢老、不敢病、不敢死。总是越想这个社会，就越觉得惨。Z世代2亿人、银发族2亿人、中产白领3亿人、小镇青年2亿人，无不都面临了房价、生活、上学、养孩子等需要花钱的地方，然而这代人并未有多高的个人资产，如果没有一个好爸爸，那这辈子可能就是房奴、车奴、奶粉奴，甚至只能维持自己的生活，而这一切就是这个社会的现状，甚至更凄惨。</p>
<p>作为21世纪的莘莘学子，大多数人都活在了互联网时代，身边有数不尽的娱乐和消耗时间的代替品，已经不在是40年前那个只能玩泥巴的时代，有人说成功的人，一定是有恒心切又付出行动的人，而“tittytainment”让更多的年轻人迷失了自我，他们一直沉迷在se情、网络游戏、看热闹打屁、刷抖音、刷偶像剧、真人秀等娱乐活动，无不沉浸在娱乐的世界，不知不觉时间都被大量的app占用。与此同时也有一部分在默默的努力，他们每天5点起床看书、学英语，乘坐地铁和公交时仍然在用小本本学英语，也有人在绞尽脑汁去想策划案，这或许就是两极分化，一部分创造，一部分享受，而这个结果或许像滚雪球一样，越来越大。</p>
<p><img src="https://cdn.bsatoshi.com/2019/02/26/15511828594442.jpg" alt="2019投资风向标"></p>
<p>很多失去，看似无奈，但都是自己的选择。</p>
<p>有人说：“选择大于努力”，当然这话得看是什么情况下，如果一个不努力的人，又何来选择，选择只是留给有准备的人而已，在有选择的情况下，作出正确的选择才是正确的。</p>
<p>19年，最早的90后已经快30了，而作为一个对自己有认知的人，或许你应该懂一点经济学、懂一点理财、懂一点金融、了解一下时政，虽说什么年龄干什么事，但是有些人就是早熟，眼光要比其他人更远，他的认知更高，知道自己应该需要什么，应该去奋斗什么。</p>
<p>19年很多人说是经济转型年，或许是下一次机会的到来，无论是制造业还是互联网，都需要进一步快速发展，而发展的背后肯定是需要政策支持，40年前成功的人可能都或多或少摸到了政策方针，而今的我们在这个大环境下，即使知道政策，依然没有办法去改变现状，因为贫富差距很大，根本做不出选择，只能安心的上好班，拿到那应得的工资然后算算房贷、花销、奶粉钱等等，或许这就是安于现状的结果，爱拼才有赢的机会，因此我们应该学会理财、学会让自己的资产变的更多。</p>
<p>年初以来国内股市和国外股市高开高走，而为何华尔街大佬还在担心？可能有人说是牛市来了，政策也放出来了，粤港湾、一带一路、万亿养老金、贸易战停战、房价调控都是刺激政策，股市何愁不涨？或许是真想多了，涨的话也顶多是恢复性上涨，今年GDP预测6.3%比往年低了，无论怎么调控，贸易战或许已经输了，想想现在的人均收入是八几年时候美国的收入，差距是30年，太可怕了。在加上美联储降息周期还未看到，而特朗普的商业强势手段，只会持续降息，或许到2021年下一任总统上任会出现更好的结果，即使是连任也是有降的可能。</p>
<p>所以说目前的股市即使涨也不会涨太久或者说是很多，而对于此种行情，或许买板块是一个选择，比如5G、人工智能、半导体、新材料、电池技术、区块链技术等相关概念股票。</p>
<p>股市飞起，房价不跌反涨，足以说明即使4-10线城市房价跌出翔，而1、2、3线城市房价也不会跌太多，刚需太多，旱的旱死涝的涝死。北上广深人在不断较少，纷纷回归故乡到2-3线城市，而这个原因或许是边际成本的增加，让互联网巨头不得不布局2-3线城市，减低开发和人员成本，同时刺激国内小城市经济，带动了商业和地产，同时增加了地方财政收入，真是一举多得。</p>
<h3 id="面对股市、房地产、虚拟货币，我们应该怎样选择？"><a href="#面对股市、房地产、虚拟货币，我们应该怎样选择？" class="headerlink" title="面对股市、房地产、虚拟货币，我们应该怎样选择？"></a>面对股市、房地产、虚拟货币，我们应该怎样选择？</h3><p><img src="https://cdn.bsatoshi.com/2019/02/26/15511829551056.jpg" alt="2019投资风向标"></p>
<ul>
<li>股市20年，房地产40年，而对于投资回报可以说都是百倍、千倍的利润，但是刚刚发展10多年的数字货币却有万倍利益，对于投机者和新兴事物感兴趣的人或许这是一个机会，而错过的则是大多数人，对于13亿国内人口红利来说，数字货币才几千万而已，而区块链技术则是更小的范围，互联网时代成就了BATTMD等巨头公司，那对于区块链技术或许将会带来下一个千亿的巨头，而千禧一代的我们没赶上改革开放、错过了房地产、那么数字币和区块链技术或许是一个新的机会，数字支付是未来的趋势，中国央行已经全球首个法定数字货币测试运行，纳斯达克今日宣布上线比特币指数BLX和以太坊指数ELX，摩根大通推出摩根币，全球无论是资本市场还是zf都在布局数字支付，因此数字货币在未来还有更大的市场。</li>
</ul>
<ul>
<li><p>对于大多数中产，或许买了车或房之后就不再有什么资产，然而有更多的人可能连投资都不懂，那么钱只会存放在银行，很多南方人认为，钱在银行就是在贬值，或许这就是认知不同，而对于钱生钱很多人还是走稳妥路线，不买股票、不炒币。可能08、15年股灾让很多新认识到股票的人都以为这是骗人的，根本不可能盈利。投机的人吓跑了，胆小的人不敢投资，国内股市20年仍然是低迷时期，都说股市对标经济，那么这样看来经济是真的很差。</p>
</li>
<li><p>作为一个会理财的人，不能把鸡蛋放到一个篮子里，因此投资则需要多元化，曾经说过43221配置资产，如果你是激进的投资者那么把4投到风险大的里面，如果你是稳健型那么把4投到稳定收益的里面。</p>
</li>
<li><p>会理财、会赚钱，不拿死工资，唯一的办法就是开辟自己的第二职业，无论是写作还是视频制作，或者是糕点师等职业，总之你需要在工作之外还有一个感兴趣的事，或许这份投资会得到意想不到的收益。偏执狂不止是偏执，也是成功的一部分。</p>
</li>
</ul>
<p>Notice：</p>
<p>1.数字货币目前买币只买比特币和以太坊<br>2.股票只买概念股（5G、半导体、新材料、环境治理等）<br>3.房地产买2-3线城市，或新一线城市（杭州、南京、成都、苏州、合肥），在就是粤港湾地区肇庆或许是不错的选择<br>4.多读书提高认知，发现新的投资</p>
<ul>
<li><p>风险警示：币聪所有文章都不构成投资推荐，仅代表个人观点，如有异议请联系官方，投资有风险，投资应该考虑个人风险承受能力，建议对项目进行深入考察，慎重做好自己的投资决策。</p>
</li>
<li><p>币聪（比特B小白）詹强威：火B资讯签约作者、金色财经、千克、今日头条、企鹅号、加密圈、32know、支点、币乎等平台专栏作者</p>
</li>
</ul>
<p>推荐文章：</p>
<p><a href="https://www.btxiaobai.com/coinbase-1" target="_blank" rel="external">币聪看点：币圈独角兽，coinbase上架的币才是值得抄底的币吗？</a></p>
<p><a href="https://www.btxiaobai.com/bsatoshi-know-hodl" target="_blank" rel="external">币聪：提升自己的边界和认知，在加上坚持，或许这样的你才会成功</a></p>
<p><a href="https://www.btxiaobai.com/ada0035ada2019" target="_blank" rel="external">币聪行情：卡尔达诺ADA支撑位0.035美元还能撑多久，ADA会在2019年创下新的历史新高吗？</a></p>
<p><a href="https://www.btxiaobai.com/nanoblock-latticenano" target="_blank" rel="external">币聪百科：什么是Nano，Block-Lattice系统是否可以改变Nano低迷走势</a></p>
<p><a href="https://www.btxiaobai.com/20182" target="_blank" rel="external">币聪科技：尽管有多头熊市，比特币交易量在2018年超过2万亿美元</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;城市安放不了躯体&lt;/p&gt;
&lt;p&gt;故乡安放不了灵魂&lt;/p&gt;
&lt;p&gt;大家好，我是币聪（比特B小白）–詹强威&lt;/p&gt;
&lt;p&gt;每天码字的非专业程序员，每晚不定点（21:50）为你罗列B圈那些事&lt;/p&gt;
&lt;p&gt;认真写作第 18 天 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://
    
    </summary>
    
      <category term="区块链" scheme="http://idiot6.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="blockchain" scheme="http://idiot6.com/tags/blockchain/"/>
    
  </entry>
  
</feed>
