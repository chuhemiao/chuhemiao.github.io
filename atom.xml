<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>梦遥奇缘</title>
  <subtitle>想要，所以才去追寻--禾子</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://idiot6.com/"/>
  <updated>2020-07-19T08:26:58.111Z</updated>
  <id>http://idiot6.com/</id>
  
  <author>
    <name>梦遥奇缘</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React Native打包安卓和Ipa指南，RN小技巧记录</title>
    <link href="http://idiot6.com/2020/07/19/React%20Native%E6%89%93%E5%8C%85%E5%AE%89%E5%8D%93%E5%92%8CIpa%E6%8C%87%E5%8D%97%EF%BC%8CRN%E5%B0%8F%E6%8A%80%E5%B7%A7%E8%AE%B0%E5%BD%95/"/>
    <id>http://idiot6.com/2020/07/19/React Native打包安卓和Ipa指南，RN小技巧记录/</id>
    <published>2020-07-19T07:55:53.000Z</published>
    <updated>2020-07-19T08:26:58.111Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CSS小技巧之文字实现竖排"><a href="#CSS小技巧之文字实现竖排" class="headerlink" title="CSS小技巧之文字实现竖排"></a>CSS小技巧之文字实现竖排</h3><ul>
<li><p>设置外层宽度，然后定位文字，给文字设置css行高（lineHeight应大于外层文字高度）</p>
<h3 id="IOS相关"><a href="#IOS相关" class="headerlink" title="IOS相关"></a>IOS相关</h3></li>
<li><p><code>error Failed to build iOS project. We ran &quot;xcodebuild&quot; command but it exited with error code 65. To debug build logs further, consider building your app with Xcode.app, by opening cleaaan.xcworkspace</code></p>
</li>
<li><p>碰到code 65 可能和ios包管理有关，<code>cd ios &amp;&amp; pod repo update &amp;&amp; pod install &amp;&amp; pod update</code></p>
</li>
<li><p>ios键盘遮挡问题，使用APSL下组件：<code>[react-native-keyboard-aware-scrollview](https://github.com/APSL/react-native-keyboard-aware-scroll-view)</code> </p>
</li>
</ul>
<h3 id="JS相关"><a href="#JS相关" class="headerlink" title="JS相关"></a>JS相关</h3><ul>
<li><code>TypeError: Invalid attempt to spread non-iterable instance</code></li>
<li>可能原因是数据和对象转换赋值导致不能遍历这个数据的问题，检查接口获取到之后的数据和当前state定义的数据之间互相赋值是否加了[…aaa],aaa为state定义的数组或对象，这里的…可能是导致错误出现的原因，去掉试试。</li>
</ul>
<h3 id="React-Native-ios打包-IPA"><a href="#React-Native-ios打包-IPA" class="headerlink" title="React Native ios打包 IPA"></a>React Native ios打包 IPA</h3><ul>
<li><p><code>mkdir release_ios</code></p>
</li>
<li><p><code>npx react-native bundle --entry-file index.js --platform ios --dev false --bundle-output release_ios/main.jsbundle --assets-dest release_ios/</code></p>
</li>
</ul>
<ul>
<li><code>release_ios</code> 下的文件 添加到xcode项目，xx项目名 -》 add files to xxx项目 -&gt;选择目录<code>release_ios-》folders</code>类型为<code>“Create folder references” -》 Add</code></li>
</ul>
<ul>
<li>添加证书、配置描述文件打包 -》·product -&gt;archive =&gt; Distribute App· =&gt; 然后有4个选择，IOS App Store 上架、Development 测试，Enterprise 企业包，然后一直下一步，导出ipa</li>
</ul>
<h3 id="React-Native-安卓打包APK"><a href="#React-Native-安卓打包APK" class="headerlink" title="React Native 安卓打包APK"></a>React Native 安卓打包APK</h3><ul>
<li>1.生成keystore</li>
<li>2.设置 gradle 变量</li>
<li>3.将签名配置加入到项目的 gradle 配置中</li>
<li><ol>
<li><code>cd  android</code></li>
</ol>
</li>
<li><ol>
<li><code>./gradlew assembleRelease</code></li>
</ol>
</li>
<li><p>keytool -genkeypair -v -keystore my-release-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000</p>
</li>
</ul>
<p>更多详细操作步骤推荐参考：</p>
<ul>
<li><a href="https://www.react-native.cn/docs/signed-apk-android" target="_blank" rel="external">React Native 官方打包APK</a></li>
<li><p><a href="https://www.devio.org/2019/11/08/react-native-Release-APP-Signature-Package-APK/" target="_blank" rel="external">新版React Native发布APP之签名打包APK</a></p>
</li>
<li><p>Notice：Macos下可能需要sudo </p>
<ul>
<li>执行 sudo ./gradlew assembleRelease</li>
</ul>
</li>
</ul>
<h3 id="安卓打包线上realease版本安装后不能发起请求http问题"><a href="#安卓打包线上realease版本安装后不能发起请求http问题" class="headerlink" title="安卓打包线上realease版本安装后不能发起请求http问题"></a>安卓打包线上realease版本安装后不能发起请求http问题</h3><ul>
<li>安卓打包realease版本后，默认 ReactNative Android9.0以上打包apk后http无法请求</li>
</ul>
<p><img src="media/15944435878136/15951436861022.jpg" alt="AndroidManifest.xml"></p>
<ul>
<li>修改 <code>/当前项目名/android/app/src/main/AndroidManifest.xml</code>，增加配置在application中 <code>android:usesCleartextTraffic=&quot;true&quot;</code></li>
</ul>
<h3 id="RN开发参考和React相关技术栈推荐"><a href="#RN开发参考和React相关技术栈推荐" class="headerlink" title="RN开发参考和React相关技术栈推荐"></a>RN开发参考和React相关技术栈推荐</h3><ul>
<li><a href="https://www.react-native.cn/" target="_blank" rel="external">React Native中文网</a></li>
<li><a href="https://reactnativeexample.com/" target="_blank" rel="external">RN常用例子和demo</a></li>
<li><a href="https://shenbao.github.io/ishehui/index.html" target="_blank" rel="external">React和RN技术、RN速查表，强烈推荐查看</a></li>
<li><a href="https://cn.redux.js.org/" target="_blank" rel="external">Store、Redux、Reducer、action等数据相关知识，必学必看</a></li>
<li><a href="https://react.iamkasong.com/" target="_blank" rel="external">React 源码技术揭秘</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CSS小技巧之文字实现竖排&quot;&gt;&lt;a href=&quot;#CSS小技巧之文字实现竖排&quot; class=&quot;headerlink&quot; title=&quot;CSS小技巧之文字实现竖排&quot;&gt;&lt;/a&gt;CSS小技巧之文字实现竖排&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设置外层宽度，然后定位文字，给文字
    
    </summary>
    
      <category term="react" scheme="http://idiot6.com/categories/react/"/>
    
    
      <category term="ios" scheme="http://idiot6.com/tags/ios/"/>
    
      <category term="React native" scheme="http://idiot6.com/tags/React-native/"/>
    
      <category term="vscode" scheme="http://idiot6.com/tags/vscode/"/>
    
      <category term="rn开发" scheme="http://idiot6.com/tags/rn%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>flutter 问题汇总</title>
    <link href="http://idiot6.com/2020/07/19/flutter%20%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://idiot6.com/2020/07/19/flutter 问题汇总/</id>
    <published>2020-07-19T07:23:53.000Z</published>
    <updated>2020-07-19T08:26:58.193Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>flutter doctor 一直卡住不动，可能是代理问题<ul>
<li>export PUB_HOSTED_URL=<a href="https://pub.flutter-io.cn" target="_blank" rel="external">https://pub.flutter-io.cn</a></li>
<li>export FLUTTER_STORAGE_BASE_URL=<a href="https://storage.flutter-io.cn" target="_blank" rel="external">https://storage.flutter-io.cn</a></li>
</ul>
</li>
</ul>
<p>macos/linux 设置中国镜像：   每次都要先执行一次 （export PATH=”$PWD/flutter/bin:$PATH”）</p>
<ol>
<li>export PUB_HOSTED_URL=<a href="https://pub.flutter-io.cn" target="_blank" rel="external">https://pub.flutter-io.cn</a></li>
<li>export FLUTTER_STORAGE_BASE_URL=<a href="https://storage.flutter-io.cn" target="_blank" rel="external">https://storage.flutter-io.cn</a></li>
<li>git clone -b dev <a href="https://github.com/flutter/flutter.git" target="_blank" rel="external">https://github.com/flutter/flutter.git</a></li>
<li>export PATH=”$PWD/flutter/bin:$PATH”</li>
<li>cd ./flutter</li>
<li>flutter doctor</li>
</ol>
<p>然后运行flutter doctor -v 更新版本</p>
<p>flutter 环境之java环境，必须使用jdk8，否则会一直提示升级。</p>
<p>git clone 加速</p>
<p>git config –global http.<a href="https://github.com.proxy" target="_blank" rel="external">https://github.com.proxy</a> socks5://127.0.0.1:7891<br>或者打开 .gitconfig 文件，输入下面配置</p>
<p>[http “<a href="https://github.com" target="_blank" rel="external">https://github.com</a>“]<br>    proxy = socks5://127.0.0.1:1086</p>
<ul>
<li><p>Waiting for another flutter command to release the startup lock…</p>
<ul>
<li>进入到你的flutter sdk目录中，然后找到bin/cache/lockfile文件，删除它即可。</li>
</ul>
</li>
</ul>
<p>CDN: trunk URL couldn’t be downloaded:<br>      <a href="https://raw.githubusercontent.com" target="_blank" rel="external">https://raw.githubusercontent.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;flutter doctor 一直卡住不动，可能是代理问题&lt;ul&gt;
&lt;li&gt;export PUB_HOSTED_URL=&lt;a href=&quot;https://pub.flutter-io.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http
    
    </summary>
    
      <category term="flutter" scheme="http://idiot6.com/categories/flutter/"/>
    
    
      <category term="ios" scheme="http://idiot6.com/tags/ios/"/>
    
      <category term="dart" scheme="http://idiot6.com/tags/dart/"/>
    
      <category term="React native" scheme="http://idiot6.com/tags/React-native/"/>
    
      <category term="flutter" scheme="http://idiot6.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>dart 基础</title>
    <link href="http://idiot6.com/2020/06/19/dart%20%E5%9F%BA%E7%A1%80/"/>
    <id>http://idiot6.com/2020/06/19/dart 基础/</id>
    <published>2020-06-19T06:03:53.000Z</published>
    <updated>2020-07-19T08:26:58.191Z</updated>
    
    <content type="html"><![CDATA[<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><ul>
<li>var 关键字</li>
<li><p>强类型语言，声明后无法改变</p>
<pre><code>var z;
z = &quot;hello world&quot;;
// 下面代码在dart中会报错，因为变量t的类型已经确定为String，
// 类型一旦确定后则不能再更改其类型。
z = 1000;
</code></pre></li>
<li><p>dynamic和Object</p>
<ul>
<li>Object 是Dart所有对象的根基类，也就是说所有类型都是Object的子类(包括Function和Null)，所以任何类型的数据都可以赋值给Object声明的对象. dynamic与var一样都是关键词,声明的变量可以赋值任意对象。 </li>
<li>dynamic与Object相同之处:”在于,他们声明的变量可以在后期改变赋值类型。”</li>
<li>dynamic与Object不同的是:”dynamic声明的对象编译器会提供所有可能的组合, 而Object声明的对象只能使用Object的属性与方法, 否则编译器会报错”<br>dynamic t;<br>Object x;<br>t = “hello world”;<br>x = ‘Hello Object’;<br>//下面代码没有问题<br>t = 1000;<br>x = 1000;</li>
</ul>
<ul>
<li>final和const<ul>
<li>不改变变量类型或值，初始化就固定</li>
<li>final 或 const，不是var，也不是一个类型。 一个 final 变量只能被设置一次</li>
<li>两者区别在于：const 变量是一个编译时常量，final变量在第一次使用时被初始化。被final或者const修饰的变量，变量类型可以省略</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>//可以省略String这个类型声明<br>final str = “hi world”;<br>//final String str = “hi world”;<br>const str1 = “hi world”;<br>//const String str1 = “hi world”;</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>Dart是一种真正的面向对象的语言，所以即使是函数也是对象，并且有一个类型Function。这意味着函数可以赋值给变量或作为参数传递给其他函数，这是函数式编程的典型特征。</li>
<li>声明一个函数：</li>
</ul>
<p>bool isNoble(int atomicNumber) {<br>  return _nobleGases[atomicNumber] != null;<br>}</p>
<ul>
<li><p>Dart函数声明如果没有显式声明返回值类型时会默认当做“dynamic处理”，注意，函数返回值没有类型推断！</p>
</li>
<li><p>对于只包含一个表达式的函数，可以使用简写语法</p>
</li>
</ul>
<p>bool isNoble (int atomicNumber)=&gt; _nobleGases [ atomicNumber ] ！= null ;</p>
<ul>
<li>函数可以作为变量：</li>
</ul>
<p>var say = (str){<br>  print(str);<br>};<br>say(“hi world”);</p>
<ul>
<li>函数作为参数传递：</li>
</ul>
<p>void execute(var callback) {<br>    callback();<br>}<br>execute(() =&gt; print(“xxx”))</p>
<ul>
<li>可选的位置参数<ul>
<li>包装一组函数参数，用[]标记为可选的位置参数，并放在参数列表的最后面：</li>
</ul>
</li>
</ul>
<p>String say(String from, String msg, [String device]) {<br>  var result = ‘$from says $msg’;<br>  if (device != null) {<br>    result = ‘$result with a $device’;<br>  }<br>  return result;<br>}</p>
<p>测试=》say(‘Bob’, ‘Howdy’); //结果是： Bob says Howdy</p>
<p>测试=&gt; say(‘Bob’, ‘Howdy’, ‘smoke signal’); //结果是：Bob says Howdy with a smoke signal</p>
<ul>
<li><strong>可选的命名参数(用的比较多)</strong><ul>
<li>定义函数时，使用{param1, param2, …}，放在参数列表的最后面，用于指定命名参数。例如：</li>
</ul>
</li>
</ul>
<p>//设置[bold]和[hidden]标志<br>void enableFlags({bool bold, bool hidden}) {<br>    // …<br>}</p>
<ul>
<li>调用函数时，可以使用指定命名参数。例如：paramName: value</li>
</ul>
<p>enableFlags(bold: true, hidden: false);</p>
<p><strong>注意，不能同时使用可选的位置参数和可选的命名参数</strong></p>
<h3 id="异步支持"><a href="#异步支持" class="headerlink" title="异步支持"></a>异步支持</h3><ul>
<li><p>Dart类库有非常多的返回Future或者Stream对象的函数。 这些函数被称为异步函数：它们只会在设置好一些耗时操作之后返回，比如像 IO操作。而不是等到这个操作完成。</p>
</li>
<li><p>async和await关键词支持了异步编程，允许您写出和同步代码很像的异步代码。</p>
</li>
<li><p>Future</p>
<ul>
<li>Future与JavaScript中的Promise非常相似，表示一个异步操作的最终完成（或失败）及其结果值的表示。</li>
<li>简单来说，它就是用于处理异步操作的，异步处理成功了就执行成功的操作，异步处理失败了就捕获错误或者停止后续操作。</li>
<li>一个Future只会对应一个结果，要么成功，要么失败。</li>
<li>Future的所有API的返回值仍然是一个Future对象，所以可以很方便的进行链式调用。</li>
</ul>
</li>
<li><p>Future API及特性 例子讲解</p>
<ul>
<li>Future.then  成功返回</li>
<li>Future.catchError 捕捉错误</li>
<li>Future.whenComplete 请求的中途想干些事</li>
<li>Future.wait 等待所有的Future成功才会走这里</li>
<li>因为只有成功和失败，捕捉到错误then方法不在执行</li>
</ul>
</li>
</ul>
<p>// 延迟2s返回结果：”hi world!”<br>Future.delayed(new Duration(seconds: 2),(){<br>   return “hi world!”;<br>}).then((data){<br>    // 执行成功走这<br>   print(data);<br>}).catchError((e){<br>   //执行失败会走到这里<br>   print(e);<br>}).whenComplete((){<br>   //无论成功或失败都会走到这里<br>});<br>// wait等待结果，4s后看到hello world<br>Future.wait([<br>  // 2秒后返回结果<br>  Future.delayed(new Duration(seconds: 2), () {<br>    return “hello”;<br>  }),<br>  // 4秒后返回结果<br>  Future.delayed(new Duration(seconds: 4), () {<br>    return “ world”;<br>  })<br>]).then((results){<br>  print(results[0]+results[1]);<br>}).catchError((e){<br>  print(e);<br>});</p>
<ul>
<li>Async/await<ul>
<li>同步方法写异步代码，利用Dart的Future返回都是Future特性可以连续调用，也可以直接用Async/await形式</li>
</ul>
</li>
</ul>
<p>// 登陆之后保存用户信息<br>task() async {<br>   try{<br>    String id = await login(“alice”,”<strong>**</strong>“);<br>    String userInfo = await getUserInfo(id);<br>    await saveUserInfo(userInfo);<br>    //执行接下来的操作<br>   } catch(e){<br>    //错误处理<br>    print(e);<br>   }<br>}</p>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><ul>
<li>也是用于接收异步事件数据，和Future 不同的是，它可以接收多个异步操作的结果（成功或失败）。 </li>
<li>也就是说，在执行异步任务时，可以通过多次触发成功或失败事件来传递结果数据或错误异常。 </li>
<li>Stream 常用于会多次读取数据的异步任务场景，如网络内容下载、文件读写等。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;变量声明&quot;&gt;&lt;a href=&quot;#变量声明&quot; class=&quot;headerlink&quot; title=&quot;变量声明&quot;&gt;&lt;/a&gt;变量声明&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;var 关键字&lt;/li&gt;
&lt;li&gt;&lt;p&gt;强类型语言，声明后无法改变&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var z;

    
    </summary>
    
      <category term="flutter" scheme="http://idiot6.com/categories/flutter/"/>
    
    
      <category term="ios" scheme="http://idiot6.com/tags/ios/"/>
    
      <category term="dart" scheme="http://idiot6.com/tags/dart/"/>
    
      <category term="React native" scheme="http://idiot6.com/tags/React-native/"/>
    
      <category term="flutter" scheme="http://idiot6.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 基础</title>
    <link href="http://idiot6.com/2020/05/29/Flutter%20%E5%9F%BA%E7%A1%80/"/>
    <id>http://idiot6.com/2020/05/29/Flutter 基础/</id>
    <published>2020-05-29T15:58:53.000Z</published>
    <updated>2020-07-19T08:26:58.111Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Stateful-widget-和Stateless-widget"><a href="#Stateful-widget-和Stateless-widget" class="headerlink" title="Stateful widget 和Stateless widget"></a>Stateful widget 和Stateless widget</h3><ul>
<li>有状态的组件（Stateful widget） 和无状态的组件（Stateless widget）有两点不同：<ul>
<li>Stateful widget可以拥有状态，这些状态在widget生命周期中是可以变的，而Stateless widget是不可变的。</li>
<li>Stateful widget至少由两个类组成：<ul>
<li>一个StatefulWidget类。</li>
<li>一个 State类； StatefulWidget类本身是不变的，但是State类中持有的状态在widget生命周期中可能会发生变化。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Navigator，MaterialPageRoute-》路由管理"><a href="#Navigator，MaterialPageRoute-》路由管理" class="headerlink" title="Navigator，MaterialPageRoute=》路由管理"></a>Navigator，MaterialPageRoute=》路由管理</h3><ul>
<li><p>路由(Route)在移动开发中通常指页面（Page），这跟web开发中单页应用的Route概念意义是相同的，Route在Android中通常指一个Activity，在iOS中指一个ViewController。所谓路由管理，就是管理页面之间如何跳转，通常也可被称为导航管理。</p>
</li>
<li><p>导航管理都会维护一个路由栈，路由入栈(push)操作对应打开一个新页面，路由出栈(pop)操作对应页面关闭操作，而路由管理主要是指如何来管理路由栈。</p>
</li>
</ul>
<p>// 路由跳转例子，调用Navigator.push方法，return到一个新的路由页面（NewRoute）</p>
<p>onPressed: () {<br>  //导航到新路由<br>  Navigator.push( context,<br>   MaterialPageRoute(builder: (context) {<br>      return NewRoute();<br>   }));<br>},</p>
<ul>
<li><p>路由之=》MaterialPageRoute</p>
<ul>
<li><p>MaterialPageRoute继承自PageRoute类，PageRoute类是一个抽象类，表示占有整个屏幕空间的一个模态路由页面，它还定义了路由构建及切换时过渡动画的相关接口及属性。MaterialPageRoute 是Material组件库提供的组件，它可以针对不同平台，实现与平台页面切换动画风格一致的路由切换动画：</p>
</li>
<li><p>对于Android，当打开新页面时，新的页面会从屏幕底部滑动到屏幕顶部；当关闭页面时，当前页面会从屏幕顶部滑动到屏幕底部后消失，同时上一个页面会显示到屏幕上。</p>
</li>
<li>对于iOS，当打开页面时，新的页面会从屏幕右侧边缘一致滑动到屏幕左边，直到新页面全部显示到屏幕上，而上一个页面则会从当前屏幕滑动到屏幕左侧而消失；当关闭页面时，正好相反，当前页面会从屏幕右侧滑出，同时上一个页面会从屏幕左侧滑入。</li>
</ul>
</li>
<li><p>MaterialPageRoute使用参数介绍</p>
</li>
</ul>
<p>MaterialPageRoute({<br>    WidgetBuilder builder,<br>    RouteSettings settings,<br>    bool maintainState = true,<br>    bool fullscreenDialog = false,<br>})</p>
<p>builder 是一个WidgetBuilder类型的回调函数，它的作用是构建路由页面的具体内容，返回值是一个widget。我们通常要实现此回调，返回新路由的实例。</p>
<p>settings 包含路由的配置信息，如路由名称、是否初始路由（首页）。</p>
<p>maintainState：默认情况下，当入栈一个新路由时，原来的路由仍然会被保存在内存中，如果想在路由没用的时候释放其所占用的所有资源，可以设置maintainState为false。</p>
<p>fullscreenDialog表示新的路由页面是否是一个全屏的模态对话框，在iOS中，如果<br>fullscreenDialog为true，新页面将会从屏幕底部滑入（而不是水平方向）。</p>
<ul>
<li><p>路由之Navigator</p>
<ul>
<li>Navigator是一个路由管理的组件，它提供了打开和退出路由页方法。Navigator通过一个栈来管理活动路由集合。通常当前屏幕显示的页面就是栈顶的路由。Navigator提供了一系列方法来管理路由栈，在此我们只介绍其最常用的两个方法：<ul>
<li>Future push(BuildContext context, Route route)</li>
<li>将给定的路由入栈（即打开新的页面），返回值是一个Future对象，用以接收新路由出栈（即关闭）时的返回数据。</li>
<li>bool pop(BuildContext context, [ result ])</li>
<li>将栈顶路由出栈，result为页面关闭时返回给上一个页面的数据。</li>
</ul>
</li>
</ul>
</li>
<li><p>判断用户是否登陆，onGenerateRoute属性</p>
<ul>
<li>它在打开命名路由时可能会被调用，之所以说可能，是因为当调用Navigator.pushNamed(…)打开命名路由时，如果指定的路由名在路由表中已注册，则会调用路由表中的builder函数来生成路由组件；如果路由表中没有注册，才会调用onGenerateRoute来生成路由。</li>
<li>全局的路由跳转前置处理逻辑。</li>
</ul>
</li>
</ul>
<h3 id="pubspec之-包管理"><a href="#pubspec之-包管理" class="headerlink" title="pubspec之 包管理"></a>pubspec之 包管理</h3><ul>
<li><p>flutter如何使用配置文件pubspec.yaml（位于项目根目录）来管理第三方依赖包。</p>
</li>
<li><p>YAML是一种直观、可读性高并且容易被人类阅读的文件格式，它和xml或Json相比，它语法简单并非常容易解析，所以YAML常用于配置文件，Flutter也是用yaml文件作为其配置文件。</p>
</li>
<li>yaml例子和参数说明：<ul>
<li>name：应用或包名称。</li>
<li>description: 应用或包的描述、简介。</li>
<li>version：应用或包的版本号。</li>
<li>dependencies：应用或包依赖的其它包或插件。</li>
<li>dev_dependencies：开发环境依赖的工具包（而不是flutter应用本身依赖的包）。</li>
<li>flutter：flutter相关的配置选项。</li>
</ul>
</li>
<li>dependencies和dev_dependencies的区别，前者的依赖包将作为APP的源码的一部分参与编译，生成最终的安装包。而后者的依赖包只是作为开发阶段的一些工具包，主要是用于帮助我们提高开发、测试效率，比如flutter的自动化测试包等</li>
</ul>
<p>name: flutter_in_action<br>description: First Flutter application.</p>
<p>version: 1.0.0+1</p>
<p>dependencies:<br>  flutter:<br>    sdk: flutter<br>  cupertino_icons: ^0.1.2<br>  // 新添加的依赖<br>  english_words: ^3.1.3<br>dev_dependencies:<br>  flutter_test:<br>    sdk: flutter</p>
<p>flutter:<br>  uses-material-design: true</p>
<ul>
<li>如何使用新包：直接将所依赖的包添加到dependencies下，然后运行：flutter packages get<h3 id="pubspec-之资源管理"><a href="#pubspec-之资源管理" class="headerlink" title="pubspec 之资源管理"></a>pubspec 之资源管理</h3></li>
<li>assets指定应包含在应用程序中的文件， 每个asset都通过相对于pubspec.yaml文件所在的文件系统路径来标识自身的路径。asset的声明顺序是无关紧要的，asset的实际目录可以是任意文件夹（在本示例中是assets文件夹）。</li>
<li><p>flutter:<br>assets:</p>
<ul>
<li>images/my_icon.png</li>
<li>images/background.png</li>
</ul>
</li>
<li><p>加载当前在pubspec设置的assets图路径,两种方法都可以</p>
</li>
</ul>
<p>Image(<br>  image: AssetImage(“images/my_icon.png”),<br>  width: 100.0<br>);</p>
<p>Image.asset(“images/avatar.png”,<br>  width: 100.0,<br>)</p>
<ul>
<li>加载网络图片：</li>
</ul>
<p>Image(<br>  image: NetworkImage(<br>      “<a href="https://avatars2.githubusercontent.com/u/20411648?s=460&amp;v=4" target="_blank" rel="external">https://avatars2.githubusercontent.com/u/20411648?s=460&amp;v=4</a>“),<br>  width: 100.0,<br>)</p>
<p>Image.network(<br>  “<a href="https://avatars2.githubusercontent.com/u/20411648?s=460&amp;v=4" target="_blank" rel="external">https://avatars2.githubusercontent.com/u/20411648?s=460&amp;v=4</a>“,<br>  width: 100.0,<br>)</p>
<ul>
<li>Image参数介绍</li>
</ul>
<p>const Image({<br>  …<br>  this.width, //图片的宽<br>  this.height, //图片高度<br>  this.color, //图片的混合色值<br>  this.colorBlendMode, //混合模式<br>  this.fit,//缩放模式<br>  this.alignment = Alignment.center, //对齐方式<br>  this.repeat = ImageRepeat.noRepeat, //重复方式<br>  …<br>})</p>
<h3 id="Pub仓库"><a href="#Pub仓库" class="headerlink" title="Pub仓库"></a>Pub仓库</h3><ul>
<li>Pub（<a href="https://pub.dev/" target="_blank" rel="external">https://pub.dev/</a> ）是Google官方的Dart Packages仓库，类似于node中的npm仓库，android中的jcenter。我们可以在Pub上面查找我们需要的包和插件，也可以向Pub发布我们的包和插件。</li>
</ul>
<h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><ul>
<li><p>官方给出的一些原则可以帮助你做决定：</p>
<ul>
<li>如果状态是用户数据，如复选框的选中状态、滑块的位置，则该状态最好由父Widget管理。</li>
<li>如果状态是有关界面外观效果的，例如颜色、动画，那么状态最好由Widget本身来管理。</li>
<li>如果某一个状态是不同Widget共享的则最好由它们共同的父Widget管理。</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Stateful-widget-和Stateless-widget&quot;&gt;&lt;a href=&quot;#Stateful-widget-和Stateless-widget&quot; class=&quot;headerlink&quot; title=&quot;Stateful widget 和Stateless
    
    </summary>
    
      <category term="flutter" scheme="http://idiot6.com/categories/flutter/"/>
    
    
      <category term="dart" scheme="http://idiot6.com/tags/dart/"/>
    
      <category term="eth" scheme="http://idiot6.com/tags/eth/"/>
    
      <category term="React native" scheme="http://idiot6.com/tags/React-native/"/>
    
      <category term="Truffle" scheme="http://idiot6.com/tags/Truffle/"/>
    
      <category term="dapps" scheme="http://idiot6.com/tags/dapps/"/>
    
  </entry>
  
  <entry>
    <title>响应式编程 RN 优缺点</title>
    <link href="http://idiot6.com/2020/05/27/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%20RN%20%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
    <id>http://idiot6.com/2020/05/27/响应式编程 RN 优缺点/</id>
    <published>2020-05-27T15:54:22.000Z</published>
    <updated>2020-07-19T08:26:58.676Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>React中提出一个重要思想：状态改变则UI随之自动改变，而React框架本身就是响应用户状态改变的事件而执行重新构建用户界面的工作，这就是典型的响应式编程范式，下面我们总结一下React中响应式原理：</p>
</li>
<li><p>开发者只需关注状态转移（数据），当状态发生变化，React框架会自动根据新的状态重新构建UI。<br>React框架在接收到用户状态改变通知后，会根据当前渲染树，结合最新的状态改变，通过Diff算法，计算出树中变化的部分，然后只更新变化的部分（DOM操作），从而避免整棵树重构，提高性能。</p>
</li>
</ul>
<h3 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h3><ul>
<li><p>上文已经提到React Native 是React 在原生移动应用平台的衍生产物，那两者主要的区别是什么呢？其实，主要的区别在于虚拟DOM映射的对象是什么？React中虚拟DOM最终会映射为浏览器DOM树，而RN中虚拟DOM会通过 JavaScriptCore 映射为原生控件树。</p>
</li>
<li><p>JavaScriptCore 是一个JavaScript解释器，它在React Native中主要有两个作用：</p>
<ul>
<li>为JavaScript提供运行环境。</li>
<li>是JavaScript与原生应用之间通信的桥梁，作用和JsBridge一样，事实上，在iOS中，很多JsBridge的实现都是基于 JavaScriptCore 。</li>
</ul>
</li>
<li><p>而RN中将虚拟DOM映射为原生控件的过程中分两步：</p>
<ul>
<li>布局消息传递； 将虚拟DOM布局信息传递给原生；</li>
<li>原生根据布局信息通过对应的原生控件渲染控件树；</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>JavaScript开发+原生渲染的方式主要优点如下：</li>
</ul>
<ol>
<li>采用Web开发技术栈，社区庞大、上手快、开发成本相对较低。</li>
<li>原生渲染，性能相比H5提高很多。</li>
<li>动态化较好，支持热更新。</li>
</ol>
<ul>
<li>不足：</li>
</ul>
<ul>
<li>渲染时需要JavaScript和原生之间通信，在有些场景如拖动可能会因为通信频繁导致卡顿。</li>
<li>JavaScript为脚本语言，执行时需要JIT(Just In Time)，执行效率和AOT(Ahead Of Time)代码仍有差距。</li>
<li>由于渲染依赖原生控件，不同平台的控件需要单独维护，并且当系统更新时，社区控件可能会滞后；除此之外，其控件系统也会受到原生UI系统限制，例如，在Android中，手势冲突消歧规则是固定的，这在使用不同人写的控件嵌套时，手势冲突问题将会变得非常棘手。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;React中提出一个重要思想：状态改变则UI随之自动改变，而React框架本身就是响应用户状态改变的事件而执行重新构建用户界面的工作，这就是典型的响应式编程范式，下面我们总结一下React中响应式原理：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;开发者只需关注状态
    
    </summary>
    
      <category term="react" scheme="http://idiot6.com/categories/react/"/>
    
    
      <category term="dart" scheme="http://idiot6.com/tags/dart/"/>
    
      <category term="eth" scheme="http://idiot6.com/tags/eth/"/>
    
      <category term="React native" scheme="http://idiot6.com/tags/React-native/"/>
    
      <category term="Truffle" scheme="http://idiot6.com/tags/Truffle/"/>
    
      <category term="dapps" scheme="http://idiot6.com/tags/dapps/"/>
    
  </entry>
  
  <entry>
    <title>加密算法系列之：des加密、aes加密、3des加密、对称加密、非对称加密、Hash 算法</title>
    <link href="http://idiot6.com/2020/05/23/%20%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E4%B9%8B%EF%BC%9Ades%E5%8A%A0%E5%AF%86%E3%80%81aes%E5%8A%A0%E5%AF%86%E3%80%813des%E5%8A%A0%E5%AF%86%E3%80%81%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E3%80%81%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E3%80%81Hash%20%E7%AE%97%E6%B3%95/"/>
    <id>http://idiot6.com/2020/05/23/ 加密算法系列之：des加密、aes加密、3des加密、对称加密、非对称加密、Hash 算法/</id>
    <published>2020-05-23T09:03:53.000Z</published>
    <updated>2020-07-19T08:26:58.003Z</updated>
    
    <content type="html"><![CDATA[<h3 id="加密算法导读"><a href="#加密算法导读" class="headerlink" title="加密算法导读"></a>加密算法导读</h3><ul>
<li><p>加密一般分为对称加密(Symmetric Key Encryption)和非对称加密(Asymmetric Key Encryption)</p>
</li>
<li><p>常见的对称加密算法：DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6 和 AES</p>
</li>
<li><p>常见的非对称加密算法：RSA、ECC （移动设备用）、Diffie-Hellman、El Gamal、DSA （数字签名用）</p>
</li>
<li><p>常见的 Hash 算法：MD2、MD4、MD5、HAVAL、SHA、SHA-1、HMAC、HMAC-MD5、HMAC-SHA1</p>
</li>
<li><p>分组加密算法中，有ECB,CBC,CFB,OFB这几种算法模式</p>
</li>
</ul>
<h3 id="什么是对称密码算法"><a href="#什么是对称密码算法" class="headerlink" title="什么是对称密码算法"></a>什么是对称密码算法</h3><ul>
<li><p>网络安全通信中要用到两类密码算法，加密一般分为对称加密(Symmetric Key Encryption)和非对称加密(Asymmetric Key Encryption)。对称密码算法有时又叫传统密码算法、秘密密钥算法或单密钥算法，非对称密码算法也叫公开密钥密码算法或双密钥算法。对称密码算法的加密密钥能够从解密密钥中推算出来，反过来也成立。在大多数对称算法中，加密解密密钥是相同的。它要求发送者和接收者在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都能对消息进行加密解密。只要通信需要保密，密钥就必须保密。</p>
</li>
<li><p>对称算法又可分为两类。一次只对明文中的单个位（有时对字节）运算的算法称为序列算法或序列密码。另一类算法是对明文的一组位进行运算，这些位组称为分组，相应的算法称为分组算法或分组密码。现代计算机密码算法的典型分组长度为64位――这个长度既考虑到分析破译密码的难度，又考虑到使用的方便性。后来，随着破译能力的发展，分组长度又提高到128位或更长。</p>
</li>
<li><p>常用的采用对称密码术的加密方案有5个组成部分：</p>
<ul>
<li>1)明文：原始信息。</li>
<li>2)加密算法：以密钥为参数，对明文进行多种置换和转换的规则和步骤，变换结果为密文。</li>
<li>3)密钥：加密与解密算法的参数，直接影响对明文进行变换的结果。</li>
<li>4)密文：对明文进行变换的结果。</li>
<li>5)解密算法：加密算法的逆变换，以密文为输入、密钥为参数，变换结果为明文。</li>
</ul>
</li>
<li><p>分组加密算法中，一般有ECB,CBC,CFB,OFB这几种算法模式。</p>
</li>
</ul>
<h3 id="什么是DES加密"><a href="#什么是DES加密" class="headerlink" title="什么是DES加密"></a>什么是DES加密</h3><ul>
<li><p>DES是Data Encryption Standard（数据加密标准）的缩写。它是由IBM公司研制的一种对称密码算法，美国国家标准局于1977年公布把它作为非机要部门使用的数据加密标准，三十年来，它一直活跃在国际保密通信的舞台上，扮演了十分重要的角色。</p>
</li>
<li><p>DES是一个分组加密算法，典型的DES以64位为分组对数据加密，加密和解密用的是同一个算法。它的密钥长度是56位（因为每个第8 位都用作奇偶校验），密钥可以是任意的56位的数，而且可以任意时候改变。其中有极少数被认为是易破解的弱密钥，但是很容易避开它们不用。所以保密性依赖于密钥。</p>
</li>
<li><p>DES加密的算法框架如下：</p>
<ul>
<li>首先要生成一套加密密钥，从用户处取得一个64位长的密码口令，然后通过等分、移位、选取和迭代形成一套16个加密密钥，分别供每一轮运算中使用。</li>
</ul>
</li>
<li><p>DES解密过程：</p>
<ul>
<li>在了解了加密过程中所有的代替、置换、异或和循环迭代之后，读者也许会认为，解密算法应该是加密的逆运算，与加密算法完全不同。恰恰相反，经过密码学家精心设计选择的各种操作，DES获得了一个非常有用的性质：加密和解密使用相同的算法！</li>
</ul>
</li>
</ul>
<p>加密工作模式：ECB、CBC、CFB、OFB</p>
<ul>
<li><p>ECB   电子密码本模式：Electronic codebook  每块堵路加密 </p>
<ul>
<li><p>优点：分块处理 并行处理</p>
</li>
<li><p>缺点：同样的原文得到相同的密文  容易被攻击</p>
</li>
</ul>
</li>
<li><p>CBC 密码分组链接：Cipher-block chaining  每块加密依赖前一块的密文</p>
<ul>
<li><p>优点：同样的原文得到不同的密文  原文微下的改变影响后面全部密文</p>
</li>
<li><p>缺点：加密需要串行处理  误差传递</p>
</li>
</ul>
</li>
<li><p>CFB Cipher Feedback (CFB)/密文反馈模式</p>
<ul>
<li>密文反馈（CFB，Cipher feedback）模式类似于CBC，可以将块密码变为自同步的流密码；工作过程亦非常相似，CFB的解密过程几乎就是颠倒的CBC的加密过程：需要使用一个与块的大小相同的移位寄存器，并用IV将寄存器初始化。然后，将寄存器内容使用块密码加密，然后将结果的最高x位与平文的x进行异或，以产生密文的x位。下一步将生成的x位密文移入寄存器中，并对下面的x位平文重复这一过程。解密过程与加密过程相似，以IV开始，对寄存器加密，将结果的高x与密文异或，产生x位平文，再将密文的下面x位移入寄存器。</li>
<li>与CBC相似，平文的改变会影响接下来所有的密文，因此加密过程不能并行化；而同样的，与CBC类似，解密过程是可以并行化的。</li>
</ul>
</li>
<li><p>OFB Output Feedback (OFB)/输出反馈模式</p>
<ul>
<li>输出反馈模式（Output feedback, OFB）可以将块密码变成同步的流密码。它产生密钥流的块，然后将其与平文块进行异或，得到密文。与其它流密码一样，密文中一个位的翻转会使平文中同样位置的位也产生翻转。这种特性使得许多错误校正码，例如奇偶校验位，即使在加密前计算而在加密后进行校验也可以得出正确结果。</li>
<li>每个使用OFB的输出块与其前面所有的输出块相关，因此不能并行化处理。然而，由于平文和密文只在最终的异或过程中使用，因此可以事先对IV进行加密，最后并行的将平文或密文进行并行的异或处理。</li>
<li>可以利用输入全0的CBC模式产生OFB模式的密钥流。这种方法十分实用，因为可以利用快速的CBC硬件实现来加速OFB模式的加密过程。</li>
</ul>
</li>
</ul>
<h3 id="什么是3DES加密"><a href="#什么是3DES加密" class="headerlink" title="什么是3DES加密"></a>什么是3DES加密</h3><ul>
<li>3DES，即triple-DES，简单地说就是3次DES加解密的组合。现已不推荐使用。（E表示Encrypt，D表示Decrypt。）</li>
<li>加密：cipthertext = E(k3, D(k2, E(k1, plaintext)))</li>
<li>解密：plaintext = D(k1, E(k2, D(k3, ciphertext)))</li>
<li>特点：如果三个密钥都一样，拿刚好和DES一样。</li>
</ul>
<h3 id="什么是AES加密"><a href="#什么是AES加密" class="headerlink" title="什么是AES加密"></a>什么是AES加密</h3><ul>
<li>AES, Advanced Encryption Standard，是现行的对称加密标准。目前（2017）如果使用对称加密，应该使用AES。当然，只能说当前AES算法是安全的，不能保证AES永远都是安全的。</li>
<li>分组：128bit。</li>
<li>密钥：128bit、192bit、256bit。</li>
<li>Go语言包只支持128bit，因此下例子中使用的是128bit</li>
</ul>
<h3 id="DSA-（Digital-Signature-Algorithm）"><a href="#DSA-（Digital-Signature-Algorithm）" class="headerlink" title="DSA （Digital Signature Algorithm）"></a>DSA （Digital Signature Algorithm）</h3><ul>
<li><p>DSA（Digital Signature Algorithm）是Schnorr和ElGamal签名算法的变种，被美国NIST作为DSS(DigitalSignature Standard)。</p>
</li>
<li><p>DSA加密算法主要依赖于整数有限域离散对数难题，素数P必须足够大，且p-1至少包含一个大素数因子以抵抗Pohlig &amp;Hellman算法的攻击。M一般都应采用信息的HASH值。DSA加密算法的安全性主要依赖于p和g，若选取不当则签名容易伪造，应保证g对于p-1的大素数因子不可约。其安全性与RSA相比差不多。</p>
</li>
<li><p>DSA 一般用于数字签名和认证。在DSA数字签名和认证中，发送者使用自己的私钥对文件或消息进行签名，接受者收到消息后使用发送者的公钥来验证签名的真实性。DSA只是一种算法，和RSA不同之处在于它不能用作加密和解密，也不能进行密钥交换，只用于签名,它比RSA要快很多.</p>
</li>
</ul>
<h3 id="ECC-（Elliptic-Curves-Cryptography），椭圆曲线密码编码学。"><a href="#ECC-（Elliptic-Curves-Cryptography），椭圆曲线密码编码学。" class="headerlink" title="ECC （Elliptic Curves Cryptography），椭圆曲线密码编码学。"></a>ECC （Elliptic Curves Cryptography），椭圆曲线密码编码学。</h3><ul>
<li><p>椭圆曲线密码学（英语：Elliptic curve cryptography，缩写为ECC），一种建立公开密钥加密的算法，基于椭圆曲线数学。椭圆曲线在密码学中的使用是在1985年由Neal Koblitz和Victor Miller分别独立提出的。</p>
</li>
<li><p>椭圆曲线密码学的主要优势是在某些情况下它比其他的方法使用更小的密钥 — — 比如RSA加密算法 — — 提供相当的或更高等级的安全。椭圆曲线密码学的另一个优势是可以定义群之间的双线性映射，基于Weil对或是Tate对；双线性映射已经在密码学中发现了大量的应用，例如基于身份的加密。不过一个缺点是加密和解密操作的实现比其他机制花费的时间长。</p>
</li>
<li><p>椭圆曲线密码学,是一种建立公开密钥加密的算法,也就输非对称加密.类似的还有RSA,EIGamal算法等.ECC被公认为在给定密钥长度下最安全的加密算法.</p>
</li>
</ul>
<p><strong>双线性映射解释：在数论中，一个双线性映射是由两个向量空间上的元素，生成第三个向量空间上一个元素之函数，并且该函数对每个参数都是线性的。</strong></p>
<h3 id="什么是RSA"><a href="#什么是RSA" class="headerlink" title="什么是RSA"></a>什么是RSA</h3><ul>
<li>RSA加密算法是一种非对称加密算法，在公开密钥加密和电子商业中被广泛使用。RSA是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。</li>
</ul>
<ul>
<li>这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。</li>
</ul>
<ul>
<li>RSA算法用到的数学知识<ul>
<li>寻找两个不相同的质数</li>
<li>模运算</li>
<li>互质数,又称互素。若N个整数的最大公因子是1，则称这N个整数互质。</li>
<li>指数运算</li>
<li>同余</li>
<li>根据欧拉函数和欧拉公式</li>
<li>模反元素</li>
</ul>
</li>
</ul>
<h3 id="ECC-和-RSA-相比"><a href="#ECC-和-RSA-相比" class="headerlink" title="ECC 和 RSA 相比"></a>ECC 和 RSA 相比</h3><ul>
<li>抗攻击性强。相同的密钥长度，其抗攻击性要强很多倍。</li>
<li>计算量小，处理速度快。ECC 总的速度比 RSA、DSA 要快得多。</li>
<li>存储空间占用小。ECC 的密钥尺寸和系统参数与 RSA、DSA 相比要小得多，意味着它所占的存贮空间要小得多。这对于加密算法在 IC 卡上的应用具有特别重要的意义。</li>
<li>带宽要求低。当对长消息进行加解密时，三类密码系统有相同的带宽要求，但应用于短消息时 ECC 带宽要求却低得多。带宽要求低使 ECC 在无线网络领域具有广泛的应用前景。</li>
</ul>
<h3 id="什么是非对称加密"><a href="#什么是非对称加密" class="headerlink" title="什么是非对称加密"></a>什么是非对称加密</h3><p>公开密钥加密（英语：public-key cryptography，又译为公开密钥加密），也称为非对称加密（asymmetric cryptography），一种密码学算法类型，在这种密码学方法中，需要一对密钥(其实这里密钥说法不好，就是“钥”)，一个是私人密钥，另一个则是公开密钥。这两个密钥是数学相关，用某用户密钥加密后所得的信息，只能用该用户的解密密钥才能解密。如果知道了其中一个，并不能计算出另外一个。因此如果公开了一对密钥中的一个，并不会危害到另外一个的秘密性质。称公开的密钥为公钥；不公开的密钥为私钥。–wiki百科</p>
<ul>
<li>指的是加、解密使用不同的密钥，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才能解密。反之，私钥加密的信息，只有公钥才能解密。俗话来说：“要想使用非对称加密算法，首先要有一对key，一个被称为private key私钥，一个成为public key公钥，然后可以把你的public key分发给想给你传密文的用户，然后用户使用该public key加密过得密文，只有使用你的private key才能解密，也就是说，只要你自己保存好你的private key，就能确保，别人想给你发的密文不被破解，所以你不用担心别人的密钥被盗，没关系。 ”</li>
</ul>
<h3 id="Hash-算法"><a href="#Hash-算法" class="headerlink" title="Hash 算法"></a>Hash 算法</h3><ul>
<li>Hash 算法特别的地方在于它是一种单向算法，用户可以通过 Hash 算法对目标信息生成一段特定长度的唯一的 Hash 值，却不能通过这个 Hash 值重新获得目标信息。因此 Hash 算法常用在不可还原的密码存储、信息完整性校验等。</li>
</ul>
<ul>
<li><p>单向散列函数一般用于产生消息摘要，密钥加密等，常见的有：</p>
<ul>
<li>MD5 （Message Digest Algorithm 5）：是 RSA 数据安全公司开发的一种单向散列算法，非可逆，相同的明文产生相同的密文；</li>
<li>SHA （Secure Hash Algorithm）：可以对任意长度的数据运算生成一个 160 位的数值。</li>
</ul>
</li>
<li><p>SHA-1 与 MD5 的比较 :</p>
<ul>
<li><p>因为二者均由 MD4 导出，SHA-1 和 MD5 彼此很相似。相应的，他们的强度和其他特性也是相似，但还有以下几点不同：</p>
</li>
<li><p>对强行供给的安全性：最显著和最重要的区别是 SHA-1 摘要比 MD5 摘要长 32 位。使用强行技术，产生任何一个报文使其摘要等于给定报摘要的难度对 MD5 是 2128 数量级的操作，而对 SHA-1 则是 2160 数量级的操作。这样，SHA-1 对强行攻击有更大的强度；</p>
</li>
<li>对密码分析的安全性：由于 MD5 的设计，易受密码分析的攻击，SHA-1 显得不易受这样的攻击；</li>
<li>速度：在相同的硬件上，SHA-1 的运行速度比 MD5 慢。</li>
</ul>
</li>
</ul>
<h3 id="对称加密与非对称加密对比"><a href="#对称加密与非对称加密对比" class="headerlink" title="对称加密与非对称加密对比"></a>对称加密与非对称加密对比</h3><ul>
<li><p>在管理方面：公钥密码算法只需要较少的资源就可以实现目的，在密钥的分配上，两者之间相差一个指数级别（一个是 n 一个是 n2）。所以私钥密码算法不适应广域网的使用，而且更重要的一点是它不支持数字签名；</p>
</li>
<li><p>在安全方面：由于公钥密码算法基于未解决的数学难题，在破解上几乎不可能。对于私钥密码算法，到了 AES 虽说从理论来说是不可能破解的，但从计算机的发展角度来看。公钥更具有优越性；</p>
</li>
<li><p>从速度上来看：AES 的软件实现速度已经达到了每秒数兆或数十兆比特。是公钥的 100 倍，如果用硬件来实现的话这个比值将扩大到 1000 倍。</p>
</li>
<li><p>对称加密优缺点：对称加密相比非对称加密算法来说，加解密的效率要高得多、加密速度快。但是缺陷在于对于密钥的管理和分发上比较困难，不是非常安全，密钥管理负担很重。</p>
</li>
<li><p>非对称加密优缺点：安全性更高，公钥是公开的，密钥是自己保存的，不需要将私钥给别人。缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</p>
</li>
</ul>
<h3 id="DES、3DES、AES、RSA（非对称加密）Go语言实现"><a href="#DES、3DES、AES、RSA（非对称加密）Go语言实现" class="headerlink" title="DES、3DES、AES、RSA（非对称加密）Go语言实现"></a>DES、3DES、AES、RSA（非对称加密）Go语言实现</h3><p>代码托管已上传到Github，请访问连接查看：<a href="https://github.com/chuhemiao/myCrypto" target="_blank" rel="external">Go语言实现加密算法</a></p>
<h3 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h3><ul>
<li>非对称加密安全，但是效率比较慢，对称加密效率高，但是不安全。</li>
<li>一般来说，密钥越长，运行的速度就越慢，应该根据的我们实际需要的安全级别来选择，一般来说，RSA 建议采用 1024 位的数字，ECC 建议采用 160 位，AES 采用 128 为即可。</li>
</ul>
<p>参考：</p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86" target="_blank" rel="external">wiki百科-公开密钥加密</a></p>
<p><a href="https://github.com/xr/xr.github.io/issues/3" target="_blank" rel="external">白话-对称加密算法 vs 非对称加密算法</a></p>
<p><a href="https://www.jianshu.com/p/b63095c59361" target="_blank" rel="external">对称加密算法和分组密码的模式</a></p>
<p><a href="https://www.chainnews.com/articles/222021126804.htm" target="_blank" rel="external">一文读懂对称加密算法、非对称加密算法和 Hash 算法</a></p>
<p><a href="https://juejin.im/post/5d2ae58f51882548ea35b9b0" target="_blank" rel="external">ECC椭圆曲线加密算法</a></p>
<p><a href="https://blog.damonare.cn/2017/12/31/RSA%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/#more" target="_blank" rel="external">RSA算法详解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;加密算法导读&quot;&gt;&lt;a href=&quot;#加密算法导读&quot; class=&quot;headerlink&quot; title=&quot;加密算法导读&quot;&gt;&lt;/a&gt;加密算法导读&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;加密一般分为对称加密(Symmetric Key Encryption)和非对称加密(As
    
    </summary>
    
      <category term="blockchain" scheme="http://idiot6.com/categories/blockchain/"/>
    
    
      <category term="golang" scheme="http://idiot6.com/tags/golang/"/>
    
      <category term="aes" scheme="http://idiot6.com/tags/aes/"/>
    
      <category term="des" scheme="http://idiot6.com/tags/des/"/>
    
      <category term="3des" scheme="http://idiot6.com/tags/3des/"/>
    
  </entry>
  
  <entry>
    <title>type annotations can only be used in typescript files.ts(8010)</title>
    <link href="http://idiot6.com/2020/05/23/type%20annotations%20can%20only%20be%20used%20in%20typescript%20files.ts(8010)/"/>
    <id>http://idiot6.com/2020/05/23/type annotations can only be used in typescript files.ts(8010)/</id>
    <published>2020-05-23T09:03:53.000Z</published>
    <updated>2020-07-19T08:26:58.594Z</updated>
    
    <content type="html"><![CDATA[<h3 id="配置VS配置文件"><a href="#配置VS配置文件" class="headerlink" title="配置VS配置文件"></a>配置VS配置文件</h3><ul>
<li>macos，preference=》setting=〉搜索 settings.json 点击Edit in settings.json</li>
<li>添加配置 <ul>
<li>“javascript.validate.enable”: false </li>
<li>“typescript.validate.enable”: false,</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;配置VS配置文件&quot;&gt;&lt;a href=&quot;#配置VS配置文件&quot; class=&quot;headerlink&quot; title=&quot;配置VS配置文件&quot;&gt;&lt;/a&gt;配置VS配置文件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;macos，preference=》setting=〉搜索 settings.j
    
    </summary>
    
      <category term="vscode" scheme="http://idiot6.com/categories/vscode/"/>
    
    
      <category term="vscode" scheme="http://idiot6.com/tags/vscode/"/>
    
      <category term="typescript" scheme="http://idiot6.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>2020年Macos最全ETH区块链环境搭建,并使用Truffle创建第一个Dapps</title>
    <link href="http://idiot6.com/2020/04/19/%202020%E5%B9%B4Macos%E6%9C%80%E5%85%A8%20ETH%E5%8C%BA%E5%9D%97%E9%93%BE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA,%E5%B9%B6%E4%BD%BF%E7%94%A8Truffle%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AADapps/"/>
    <id>http://idiot6.com/2020/04/19/ 2020年Macos最全 ETH区块链环境搭建,并使用Truffle创建第一个Dapps/</id>
    <published>2020-04-19T15:23:53.000Z</published>
    <updated>2020-07-19T08:26:58.003Z</updated>
    
    <content type="html"><![CDATA[<h3 id="以太坊开需要哪些工具"><a href="#以太坊开需要哪些工具" class="headerlink" title="以太坊开需要哪些工具"></a>以太坊开需要哪些工具</h3><ul>
<li><p>HomeBrew</p>
</li>
<li><p>Xcode命令行工具</p>
</li>
<li><p>go-ethereum</p>
</li>
<li><p>Ganache</p>
</li>
<li><p>nodejs和npm</p>
</li>
<li><p>Truffle</p>
</li>
<li><p>VsCode</p>
</li>
</ul>
<h3 id="安装HOMEBREW"><a href="#安装HOMEBREW" class="headerlink" title="安装HOMEBREW"></a>安装HOMEBREW</h3><ul>
<li><p>如果已经安装请忽略本步骤</p>
</li>
<li><p>请打开<a href="https://brew.sh/，然后复制红框内内容" target="_blank" rel="external">https://brew.sh/，然后复制红框内内容</a>: <code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></p>
</li>
</ul>
<p><img src="https://cdn.bsatoshi.com/2019/12/14/15763112879761.jpg" alt="homebrew"></p>
<h3 id="安装Xcode"><a href="#安装Xcode" class="headerlink" title="安装Xcode"></a>安装Xcode</h3><ul>
<li>一般电脑应该会有，没有的话，那自行谷歌把！</li>
</ul>
<h3 id="安装geth"><a href="#安装geth" class="headerlink" title="安装geth"></a>安装geth</h3><ul>
<li>brew tap ethereum/ethereum</li>
<li><p>brew install ethereum</p>
</li>
<li><p>检测是否安装完成：输入geth -h，如果出现下图所示，则代表已经安装完成</p>
</li>
</ul>
<h3 id="nodejs和npm"><a href="#nodejs和npm" class="headerlink" title="nodejs和npm"></a>nodejs和npm</h3><ul>
<li><p>brew install node</p>
</li>
<li><p>node -v 检测是否已经安装成功</p>
</li>
<li><p>npm -v</p>
</li>
</ul>
<h3 id="安装truffle"><a href="#安装truffle" class="headerlink" title="安装truffle"></a>安装truffle</h3><ul>
<li><p>npm install -g truffle</p>
</li>
<li><p>truffle -v 检测是否安装成功</p>
</li>
</ul>
<h3 id="安装Ganache"><a href="#安装Ganache" class="headerlink" title="安装Ganache"></a>安装Ganache</h3><ul>
<li><p>浏览器中打开下面的链接，<a href="https://www.trufflesuite.com/ganache" target="_blank" rel="external">https://www.trufflesuite.com/ganache</a></p>
</li>
<li><p>下载Ganache for MacOS ，然后点击下载后的dmg包，依次按步骤执行即可。</p>
</li>
<li><p>然后启动此软件，就可以进行相关调试了，如下图</p>
</li>
</ul>
<p><img src="https://cdn.bsatoshi.com/2019/12/14/15763116506866.jpg" alt="安装Ganache"></p>
<h3 id="安装VsCode"><a href="#安装VsCode" class="headerlink" title="安装VsCode"></a>安装VsCode</h3><ul>
<li><p>打开网页：<a href="https://code.visualstudio.com/，下载后直接打开。" target="_blank" rel="external">https://code.visualstudio.com/，下载后直接打开。</a></p>
</li>
<li><p>然后安装插件，先点击步骤1，然后在步骤上直接搜索当前要安装的插件名称，然后点击install即可</p>
</li>
</ul>
<p><img src="https://cdn.bsatoshi.com/2019/12/14/15763119152803.jpg" alt="安装VsCode"></p>
<h3 id="创建第一个dapp"><a href="#创建第一个dapp" class="headerlink" title="创建第一个dapp"></a>创建第一个dapp</h3><ul>
<li><p>首先上述软件已经安装成功，然后打开Ganache客户端，可以看到已经分配的测试网账户和一些余额。</p>
</li>
<li><p>然后打开终端，创建一个目录mkdir blockchain-test</p>
</li>
<li>cd blockchain-test</li>
<li><p>使用前面安装的truffle创建项目，这里推荐使用truffle box 模式，它会带一些自动的事例，具体可以看文档和一些已经存在的项目：<a href="https://www.trufflesuite.com/boxes" target="_blank" rel="external">https://www.trufflesuite.com/boxes</a></p>
</li>
<li><p>这里我们以<a href="https://www.trufflesuite.com/boxes/pet-shop" target="_blank" rel="external">pet-shop</a>,首先执行：sudo truffle unbox pet-shop</p>
</li>
</ul>
<p><img src="https://cdn.bsatoshi.com/2019/12/14/15763125307985.jpg" alt="创建第一个dapp"></p>
<ul>
<li>然后得到新项目目录如下</li>
</ul>
<p><img src="https://cdn.bsatoshi.com/2019/12/14/15763126268873.jpg" alt="创建第一个dapp"></p>
<ul>
<li><p>contracts/ : 包含所有項目中智能合約 Solidity 代码，其中有事例 Migrations.sol 智能合約，容后再介紹；</p>
</li>
<li><p>migrations/ : 主要是 Truffle 用与部署智能合約的一个迁移命令集；</p>
</li>
<li><p>test/ : 包含 JavaScript 和 Solidity 的 test cases；</p>
</li>
<li><p>truffle-config.js : Truffle 的一些设置，比如端口、测试网、正式网等；</p>
</li>
<li><p>node_modules ： 是一些安装的基础包</p>
</li>
<li><p>bs-config.json:是智能合约的编译鲁姆</p>
</li>
<li><p>src：是项目的主入口文件</p>
</li>
<li><p>然后分别依次执行 ： </p>
<ul>
<li>truffle compile</li>
<li>truffle migrate</li>
<li>truffle test</li>
<li>npm run dev</li>
</ul>
</li>
<li><p>然后就可以看到程序已经跑起来：</p>
</li>
</ul>
<p><img src="https://cdn.bsatoshi.com/2019/12/14/15763132463521.jpg" alt="truffle创建第一个dapp"></p>
<ul>
<li>然后程序会默认打开浏览器，也可以直接访问：<a href="http://localhost:3000" target="_blank" rel="external">http://localhost:3000</a> 查看已经得到的效果</li>
</ul>
<p><img src="https://cdn.bsatoshi.com/2019/12/14/15763132695654.jpg" alt="truffle创建第一个dapp"></p>
<ul>
<li>访问：<a href="http://localhost:3001可以看到智能合约的一些交互和当前dapp的一些运行情况，如下图：" target="_blank" rel="external">http://localhost:3001可以看到智能合约的一些交互和当前dapp的一些运行情况，如下图：</a></li>
</ul>
<p><img src="https://cdn.bsatoshi.com/2019/12/14/15763134408246.jpg" alt="truffle创建第一个dapp"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;以太坊开需要哪些工具&quot;&gt;&lt;a href=&quot;#以太坊开需要哪些工具&quot; class=&quot;headerlink&quot; title=&quot;以太坊开需要哪些工具&quot;&gt;&lt;/a&gt;以太坊开需要哪些工具&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;HomeBrew&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Xco
    
    </summary>
    
      <category term="flutter" scheme="http://idiot6.com/categories/flutter/"/>
    
    
      <category term="dart" scheme="http://idiot6.com/tags/dart/"/>
    
      <category term="eth" scheme="http://idiot6.com/tags/eth/"/>
    
      <category term="React native" scheme="http://idiot6.com/tags/React-native/"/>
    
      <category term="Truffle" scheme="http://idiot6.com/tags/Truffle/"/>
    
      <category term="dapps" scheme="http://idiot6.com/tags/dapps/"/>
    
  </entry>
  
  <entry>
    <title>2020最新Macos eos区块链环境搭建和开发教程</title>
    <link href="http://idiot6.com/2020/03/29/%202020%E6%9C%80%E6%96%B0Macos%20eos%E5%8C%BA%E5%9D%97%E9%93%BE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/"/>
    <id>http://idiot6.com/2020/03/29/ 2020最新Macos eos区块链环境搭建和开发教程/</id>
    <published>2020-03-29T14:22:22.000Z</published>
    <updated>2020-07-19T08:26:58.003Z</updated>
    
    <content type="html"><![CDATA[<p><strong>EOS、EOS-Mainnet、EOSIO都是什么？</strong></p>
<h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><ul>
<li><p>2017年，一个叫Block.one的公司开发了一个叫EOSIO的软件。为了开发这个软件，Block.one进行了一个历时350天的众筹，最后募集资金超过40亿美元。</p>
</li>
<li><p>EOSIO这个软件是后来的EOS-Mainnet和其他区块链网络（BOS、Telos等等）构建网络的基础工具。</p>
</li>
<li><p>EOS-Mainnet，也就是EOS主网，是我们目前使用最广泛的基于EOSIO软件的区块链网络。网上听说的很多EOS Dapp（Decentralized Application，去中心化的app）都是运行在EOS主网上，大多数人一说EOS，基本上指的就是EOS主网。</p>
</li>
<li><p>EOS是EOS主网上的原生代币的符号，EOS的数量体现了你在EOS主网上可使用资源和可参与治理的多少。EOS本身具有价格，可以在各大交易所购买。</p>
</li>
</ul>
<h3 id="账户、公钥、私钥"><a href="#账户、公钥、私钥" class="headerlink" title="账户、公钥、私钥"></a>账户、公钥、私钥</h3><ul>
<li><p>在EOS上，账户类似于用户名，所有的操作都是以账户为基础的，转账、投票、更新信息，参与Dapp等等。账户需要注册，至多12位字符。</p>
</li>
<li><p>如何证明这个账户是属于你的而不是别人的呢？这个就需要用到公钥和私钥，用互联网来类比的话就是密码，不过这个密码是由公钥和私钥两部分构成的。<br>形象地理解，公钥和私钥就相当于锁和钥匙，私钥，也就是钥匙，掌握在你自己手里；公钥，也就是锁，和账户绑定。如果你想在账户里进行操作，就需要用你手里的私钥和公钥匹配，如果匹配上了，那么账户就认为你是所有者。</p>
</li>
<li><p>实际上，EOS的账户系统还可以更加复杂，比如给予每个公钥/私钥对不同的权限（Owner和Active），对一个账户就行多人共管（Multi-sig，多签）等等，暂时先不展开了。<br>注意，一个公钥/私钥对可以同时控制多个账户。</p>
</li>
</ul>
<p>（三）钱包</p>
<ul>
<li><p>常用的钱包，PC端和国外主要用Scatter，手机端和国内主要用TokenPocket、Meetone。这些可以通过他们的官网下载。</p>
</li>
<li><p>每个EOS账户里面存在着三者资源，所有的操作都需要花费这三种资源，可以理解，这三种资源是你使用EOS网络的成本。这三种资源叫做计算（CPU）、存储（RAM）和网络（NET）。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>项目</th>
<th>传统含义</th>
<th>EOS上含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>计算（CPU）</td>
<td>中央处理单元，指的是负责在计算机中执行指令和处理信息的硬件</td>
<td>一种按时间计价的资源（单位：微秒），用来衡量EOS节点应该对你帐户中的交易确认所投入的时间</td>
</tr>
<tr>
<td>网络（NET）</td>
<td>互联网带宽</td>
<td>一种以空间计价的资源（单位：字节），用来衡量当在P2P层上传输数据时需要多少区块的网络描述来存储你的交易数据</td>
</tr>
<tr>
<td>存储（RAM）</td>
<td>存储是用来存储云平台上的所有数据。RAM是指运行内存，速度更快，但储存是暂时的，断电后内容就会消失</td>
<td>RAM不再是临时存储，而是作为主储存层，用来储存所有的数据。相当于是让储存速度更快的内存（RAM）充当了硬盘的功能。在RAM中存储数据库，可以让读取数据的速度更快</td>
</tr>
</tbody>
</table>
<h3 id="EOSIO如何快速构建开发网络"><a href="#EOSIO如何快速构建开发网络" class="headerlink" title="EOSIO如何快速构建开发网络"></a>EOSIO如何快速构建开发网络</h3><ul>
<li>EOSIO是由三个组件组成的。<ul>
<li>nodeos:管理区块链节点的组件。</li>
<li>keosd：管理钱包的组件。</li>
<li>cleos：控制区块链和钱包CLI工具。</li>
</ul>
</li>
</ul>
<h3 id="Macos-安装EOSIO"><a href="#Macos-安装EOSIO" class="headerlink" title="Macos 安装EOSIO"></a>Macos 安装EOSIO</h3><ul>
<li><p>安装  <code>brew tap eosio/eosio</code>   <code>brew install eosio</code></p>
</li>
<li><p>卸载 <code>brew remove eosio</code></p>
</li>
</ul>
<h3 id="Ubuntu-18-04-Debian-安装-eosio"><a href="#Ubuntu-18-04-Debian-安装-eosio" class="headerlink" title="Ubuntu 18.04  Debian 安装 eosio"></a>Ubuntu 18.04  Debian 安装 eosio</h3><ul>
<li><p>wget <a href="https://github.com/EOSIO/eos/releases/download/v1.8.6/eosio_1.8.6-1-ubuntu-18.04_amd64.deb" target="_blank" rel="external">https://github.com/EOSIO/eos/releases/download/v1.8.6/eosio_1.8.6-1-ubuntu-18.04_amd64.deb</a></p>
</li>
<li><p>sudo apt install ./eosio_1.8.6-1-ubuntu-18.04_amd64.deb</p>
</li>
</ul>
<h3 id="Ubuntu-16-04-Debian-安装-eosio"><a href="#Ubuntu-16-04-Debian-安装-eosio" class="headerlink" title="Ubuntu 16.04 Debian 安装 eosio"></a>Ubuntu 16.04 Debian 安装 eosio</h3><ul>
<li><p>wget <a href="https://github.com/EOSIO/eos/releases/download/v1.8.6/eosio_1.8.6-1-ubuntu-16.04_amd64.deb" target="_blank" rel="external">https://github.com/EOSIO/eos/releases/download/v1.8.6/eosio_1.8.6-1-ubuntu-16.04_amd64.deb</a></p>
</li>
<li><p>sudo apt install ./eosio_1.8.6-1-ubuntu-18.04_amd64.deb</p>
</li>
</ul>
<h3 id="CentOS-通过RPM-安装-eosio"><a href="#CentOS-通过RPM-安装-eosio" class="headerlink" title="CentOS 通过RPM  安装 eosio"></a>CentOS 通过RPM  安装 eosio</h3><ul>
<li><p>wget <a href="https://github.com/EOSIO/eos/releases/download/v1.8.6/eosio-1.8.6-1.el7.x86_64.rpm" target="_blank" rel="external">https://github.com/EOSIO/eos/releases/download/v1.8.6/eosio-1.8.6-1.el7.x86_64.rpm</a></p>
</li>
<li><p>sudo yum install ./eosio-1.8.6-1.el7.x86_64.rpm</p>
</li>
</ul>
<h3 id="设置一个开发目录"><a href="#设置一个开发目录" class="headerlink" title="设置一个开发目录"></a>设置一个开发目录</h3><ul>
<li><p>cd /data  mkdir development-eos</p>
</li>
<li><p>cd development-eos  进入开发目录</p>
</li>
</ul>
<h3 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h3><ul>
<li><p>keosd &amp;</p>
</li>
<li><p>如果成功则会看到如下截图：</p>
</li>
</ul>
<p><img src="https://cdn.bsatoshi.com/2019/12/14/15763095080716.jpg" alt="keosd"></p>
<h3 id="启动nodeos"><a href="#启动nodeos" class="headerlink" title="启动nodeos"></a>启动nodeos</h3><pre><code>nodeos -e -p eosio \
--plugin eosio::producer_plugin \
--plugin eosio::chain_api_plugin \
--plugin eosio::http_plugin \
--plugin eosio::history_plugin \
--plugin eosio::history_api_plugin \
--filter-on=&quot;*&quot; \
--access-control-allow-origin=&apos;*&apos; \
--contracts-console \
--http-validate-host=false \
--verbose-http-errors &gt;&gt; nodeos.log 2&gt;&amp;1 &amp;
</code></pre><h3 id="查看nodeos-log是否已经启动nodeos"><a href="#查看nodeos-log是否已经启动nodeos" class="headerlink" title="查看nodeos.log是否已经启动nodeos"></a>查看nodeos.log是否已经启动nodeos</h3><ul>
<li>tail -f nodeos.log</li>
</ul>
<p><img src="https://cdn.bsatoshi.com/2019/12/14/15763097186602.jpg" alt="nodeos.log"></p>
<h3 id="查看当前已经存在的eos钱包"><a href="#查看当前已经存在的eos钱包" class="headerlink" title="查看当前已经存在的eos钱包"></a>查看当前已经存在的eos钱包</h3><ul>
<li><p>cleos wallet list</p>
</li>
<li><p>不出意外应该会返回一个空的数组，当前我们并没有创建钱包</p>
</li>
</ul>
<h3 id="检查Nodeos-的端口"><a href="#检查Nodeos-的端口" class="headerlink" title="检查Nodeos 的端口"></a>检查Nodeos 的端口</h3><ul>
<li>浏览器打开：<a href="http://localhost:8888/v1/chain/get_info" target="_blank" rel="external">http://localhost:8888/v1/chain/get_info</a>  当然你也可以直接使用curl的方式：curl <a href="http://localhost:8888/v1/chain/get_info" target="_blank" rel="external">http://localhost:8888/v1/chain/get_info</a></li>
</ul>
<p><img src="https://cdn.bsatoshi.com/2019/12/14/15763099467987.jpg" alt="检查Nodeos 的端口"></p>
<h3 id="Macos安装CDT"><a href="#Macos安装CDT" class="headerlink" title="Macos安装CDT"></a>Macos安装CDT</h3><ul>
<li>brew tap eosio/eosio.cdt</li>
<li><p>brew install eosio.cdt</p>
</li>
<li><p>卸载CDT  brew remove eosio.cdt</p>
</li>
</ul>
<h3 id="CentOS-Redhat内核安装CDT"><a href="#CentOS-Redhat内核安装CDT" class="headerlink" title="CentOS/Redhat内核安装CDT"></a>CentOS/Redhat内核安装CDT</h3><ul>
<li><p>wget <a href="https://github.com/EOSIO/eosio.cdt/releases/download/v1.6.3/eosio.cdt-1.6.3-1.el7.x86_64.rpm" target="_blank" rel="external">https://github.com/EOSIO/eosio.cdt/releases/download/v1.6.3/eosio.cdt-1.6.3-1.el7.x86_64.rpm</a></p>
</li>
<li><p>sudo yum install ./eosio.cdt-1.6.3-1.el7.x86_64.rpm</p>
</li>
<li><p>卸载CDT   sudo yum remove eosio.cdt</p>
</li>
</ul>
<h3 id="通过源码编译方式安装CDT"><a href="#通过源码编译方式安装CDT" class="headerlink" title="通过源码编译方式安装CDT"></a>通过源码编译方式安装CDT</h3><ul>
<li>首先克隆下源码 git clone –recursive <a href="https://github.com/eosio/eosio.cdt" target="_blank" rel="external">https://github.com/eosio/eosio.cdt</a> –branch v1.6.3 –single-branch</li>
</ul>
<ul>
<li><p>然后执行 cd eosio.cdt   ./build.sh</p>
</li>
<li><p>sudo ./install.sh</p>
</li>
</ul>
<h3 id="创建一个开发模式的钱包"><a href="#创建一个开发模式的钱包" class="headerlink" title="创建一个开发模式的钱包"></a>创建一个开发模式的钱包</h3><ul>
<li><p>首先执行创建钱包的命令：cleos wallet create –to-console  ， 此时cleos会返回一个密码，你可以存在任何地方，后续以备使用。</p>
</li>
<li><p>打开一个eos钱包：cleos wallet open</p>
</li>
<li><p>返回钱包的列表查看目前可以打开的钱包：cleos wallet list</p>
</li>
<li><p>打开之前首先需要解锁：cleos wallet unlock</p>
</li>
<li><p>然后在输入：cleos wallet list，会看到列表的钱包后面会增加一个*号，然后就可以在执行打开命令打开。</p>
</li>
</ul>
<h3 id="生成带有密钥的EOS钱包"><a href="#生成带有密钥的EOS钱包" class="headerlink" title="生成带有密钥的EOS钱包"></a>生成带有密钥的EOS钱包</h3><ul>
<li>cleos wallet create_key</li>
<li><p>运行上述命令后会得到一个新的key： “EOS8PEJ5FM4LLLpHK…X6PypHu97kqGDJQY5Y”</p>
</li>
<li><p>在网页<a href="https://developers.eos.io/eosio-home/docs/wallets" target="_blank" rel="external">https://developers.eos.io/eosio-home/docs/wallets</a> 的第五步输入上述得到的key就可以得到一个开发的Public key</p>
</li>
</ul>
<h3 id="导出开发的密钥"><a href="#导出开发的密钥" class="headerlink" title="导出开发的密钥"></a>导出开发的密钥</h3><ul>
<li>cleos wallet import，运行命令后会得到一串字符串（private key），包存后可以用来后期的开发</li>
</ul>
<h3 id="创建eos测试账户"><a href="#创建eos测试账户" class="headerlink" title="创建eos测试账户"></a>创建eos测试账户</h3><ul>
<li><p>使用命令分别创建bob和alice两个账户，YOUR_PUBLIC_KEY是之前步骤生成的key</p>
</li>
<li><p>cleos create account eosio bob YOUR_PUBLIC_KEY </p>
</li>
<li><p>cleos create account eosio alice YOUR_PUBLIC_KEY</p>
</li>
<li><p>运行命令后会反馈当前广播交易的消息</p>
</li>
</ul>
<h3 id="获取Public-Key"><a href="#获取Public-Key" class="headerlink" title="获取Public Key"></a>获取Public Key</h3><ul>
<li>cleos get account alice（当前创建的用户）</li>
</ul>
<p><img src="https://cdn.bsatoshi.com/2019/12/14/15763107114594.jpg" alt="获取Public Key"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://developers.eos.io/eosio-home/docs/setting-up-your-environment" target="_blank" rel="external">developers eos</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;EOS、EOS-Mainnet、EOSIO都是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;20
    
    </summary>
    
      <category term="flutter" scheme="http://idiot6.com/categories/flutter/"/>
    
    
      <category term="dart" scheme="http://idiot6.com/tags/dart/"/>
    
      <category term="eth" scheme="http://idiot6.com/tags/eth/"/>
    
      <category term="React native" scheme="http://idiot6.com/tags/React-native/"/>
    
      <category term="Truffle" scheme="http://idiot6.com/tags/Truffle/"/>
    
      <category term="dapps" scheme="http://idiot6.com/tags/dapps/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言解决不能Go get安装Gin问题解决方案</title>
    <link href="http://idiot6.com/2019/07/23/go-gin-golang-x/"/>
    <id>http://idiot6.com/2019/07/23/go-gin-golang-x/</id>
    <published>2019-07-23T09:03:53.000Z</published>
    <updated>2020-04-07T16:41:29.008Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Go get 出现超时问题：“golang unrecognized import path &quot;golang.org/x/net   unrecognized import path &quot;golang.org/x/sys&quot;  Unknown SSL protocol error in connection to gopkg.in:443 &quot;”</div></pre></td></tr></table></figure>
<h3 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2.解决办法"></a>2.解决办法</h3><ul>
<li>网络上解决方案1手动下载：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir $GOPATH/src/golang.org/x</div><div class="line">cd $GOPATH/src/golang.org/x</div><div class="line">git clone git@github.com:golang/text.git</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="方案二：设置代理"><a href="#方案二：设置代理" class="headerlink" title="方案二：设置代理"></a>方案二：设置代理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export http_proxy=https://proxyAddress:port</div><div class="line">export https_proxy=https://proxyAddress:port</div></pre></td></tr></table></figure>
<h3 id="3-最佳解决方案"><a href="#3-最佳解决方案" class="headerlink" title="3.最佳解决方案"></a>3.最佳解决方案</h3><ul>
<li><p>从 Go 1.11 版本开始已经开始支持Go Mod ，并且提供了包下载的解决方案，就是使用 <a href="https://goproxy.io/" target="_blank" rel="external">https://goproxy.io/</a> 直接代理下载，官方设置方法：</p>
</li>
<li><p>macos/linux  </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export GO111MODULE=on </div><div class="line">export GOPROXY=https://goproxy.io</div></pre></td></tr></table></figure>
<ul>
<li>Wins 使用PowerShell 设置（这里输入是去当前设置的GOPATH）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$env:GO111MODULE=&quot;on&quot;</div><div class="line">$env:GOPROXY=&quot;https://goproxy.io&quot;</div></pre></td></tr></table></figure>
<p><img src="https://cdn.bsatoshi.com/2019/07/23/72B1D829-1628-4CC9-8129-053951E159C2.png" alt="go-gin-golang"></p>
<ul>
<li>提示这里需要加入引号，否则会报on或地址有问题，之后在执行Go get 等其他命令都一帆风顺了。</li>
</ul>
<h3 id="Notice：-如果你使用的Go-version-》-1-13-请使用"><a href="#Notice：-如果你使用的Go-version-》-1-13-请使用" class="headerlink" title="Notice： 如果你使用的Go version 》=1.13  请使用"></a>Notice： 如果你使用的Go version 》=1.13  请使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">go env -w GOPROXY=https://goproxy.io,direct</div><div class="line">go env -w GOPRIVATE=*.corp.example.com</div></pre></td></tr></table></figure>
<p>Go 成功安装Gin框架并使用Go mod管理</p>
<p><img src="https://cdn.bsatoshi.com/2019/07/23/1C3E1CAC-D142-49F0-95C8-5243B1EB701C.png" alt="安装Gin框架并使用Go"></p>
<p>参考资料：<br><a href="https://goproxy.io/" target="_blank" rel="external">https://goproxy.io/</a><br><a href="https://segmentfault.com/a/1190000018264719" target="_blank" rel="external">一键解决 go get golang.org/x 包失败</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-问题描述&quot;&gt;&lt;a href=&quot;#1-问题描述&quot; class=&quot;headerlink&quot; title=&quot;1.问题描述&quot;&gt;&lt;/a&gt;1.问题描述&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
    
    </summary>
    
      <category term="GO" scheme="http://idiot6.com/categories/GO/"/>
    
    
      <category term="golang" scheme="http://idiot6.com/tags/golang/"/>
    
      <category term="gin" scheme="http://idiot6.com/tags/gin/"/>
    
      <category term="echo" scheme="http://idiot6.com/tags/echo/"/>
    
      <category term="goproxy" scheme="http://idiot6.com/tags/goproxy/"/>
    
  </entry>
  
  <entry>
    <title>2019这个转折年投资风向标应该是A股、币圈还是房地产，你会选哪个？</title>
    <link href="http://idiot6.com/2019/04/10/blockchain_ticker/"/>
    <id>http://idiot6.com/2019/04/10/blockchain_ticker/</id>
    <published>2019-04-10T11:22:27.000Z</published>
    <updated>2019-04-10T11:30:59.868Z</updated>
    
    <content type="html"><![CDATA[<p>城市安放不了躯体</p>
<p>故乡安放不了灵魂</p>
<p>大家好，我是币聪（比特B小白）–詹强威</p>
<p>每天码字的非专业程序员，每晚不定点（21:50）为你罗列B圈那些事</p>
<p>认真写作第 18 天 </p>
<p><img src="https://cdn.bsatoshi.com/2019/02/26/15422863789126.jpg" alt="2019投资风向标"></p>
<p>投资理财是指投资者通过合理安排资金，运用诸如储蓄、银行理财产品、债券、基金、股票、期货、外汇、房地产、保险以及黄金等投资理财工具对个人、家庭和企事业单位资产进行管理和分配，达到保值增值的目的，从而加速资产的增长。</p>
<p>投资理财不等于简单的攒钱、存钱，把钱放在银行里，也不等于简单的炒股(股票买卖)。投资理财是根据需求和目的将所有财产和负债，其中包括有形的、无形的、流动的、非流动的、过去的、现在的、未来的、遗产、遗嘱及知识产权等在内的所有资产和负债进行积极主动的策划、安排、置换、重组等使其达到保值、增值的综合的、系统的、全面的经济活动。前者只是投资的一种具体行为，充其量为现金的使用。作为投资理财一部分的现金管理要比它复杂得多，也难得多。–自MBA智库</p>
<p>国内很多人都说：“富不过三代”，其实是有原因的，不注重理财和资产管理，只会慢慢走向衰落，因此理财对于千禧一代或许是新的机会，可以选择基金、股票、数字币…</p>
<p>改革开放40年来，已经早就了很多很多的已经成功的人士，而也给千禧一代带来了巨大的压力，90后、00后已经成为了不敢生、不敢老、不敢病、不敢死。总是越想这个社会，就越觉得惨。Z世代2亿人、银发族2亿人、中产白领3亿人、小镇青年2亿人，无不都面临了房价、生活、上学、养孩子等需要花钱的地方，然而这代人并未有多高的个人资产，如果没有一个好爸爸，那这辈子可能就是房奴、车奴、奶粉奴，甚至只能维持自己的生活，而这一切就是这个社会的现状，甚至更凄惨。</p>
<p>作为21世纪的莘莘学子，大多数人都活在了互联网时代，身边有数不尽的娱乐和消耗时间的代替品，已经不在是40年前那个只能玩泥巴的时代，有人说成功的人，一定是有恒心切又付出行动的人，而“tittytainment”让更多的年轻人迷失了自我，他们一直沉迷在se情、网络游戏、看热闹打屁、刷抖音、刷偶像剧、真人秀等娱乐活动，无不沉浸在娱乐的世界，不知不觉时间都被大量的app占用。与此同时也有一部分在默默的努力，他们每天5点起床看书、学英语，乘坐地铁和公交时仍然在用小本本学英语，也有人在绞尽脑汁去想策划案，这或许就是两极分化，一部分创造，一部分享受，而这个结果或许像滚雪球一样，越来越大。</p>
<p><img src="https://cdn.bsatoshi.com/2019/02/26/15511828594442.jpg" alt="2019投资风向标"></p>
<p>很多失去，看似无奈，但都是自己的选择。</p>
<p>有人说：“选择大于努力”，当然这话得看是什么情况下，如果一个不努力的人，又何来选择，选择只是留给有准备的人而已，在有选择的情况下，作出正确的选择才是正确的。</p>
<p>19年，最早的90后已经快30了，而作为一个对自己有认知的人，或许你应该懂一点经济学、懂一点理财、懂一点金融、了解一下时政，虽说什么年龄干什么事，但是有些人就是早熟，眼光要比其他人更远，他的认知更高，知道自己应该需要什么，应该去奋斗什么。</p>
<p>19年很多人说是经济转型年，或许是下一次机会的到来，无论是制造业还是互联网，都需要进一步快速发展，而发展的背后肯定是需要政策支持，40年前成功的人可能都或多或少摸到了政策方针，而今的我们在这个大环境下，即使知道政策，依然没有办法去改变现状，因为贫富差距很大，根本做不出选择，只能安心的上好班，拿到那应得的工资然后算算房贷、花销、奶粉钱等等，或许这就是安于现状的结果，爱拼才有赢的机会，因此我们应该学会理财、学会让自己的资产变的更多。</p>
<p>年初以来国内股市和国外股市高开高走，而为何华尔街大佬还在担心？可能有人说是牛市来了，政策也放出来了，粤港湾、一带一路、万亿养老金、贸易战停战、房价调控都是刺激政策，股市何愁不涨？或许是真想多了，涨的话也顶多是恢复性上涨，今年GDP预测6.3%比往年低了，无论怎么调控，贸易战或许已经输了，想想现在的人均收入是八几年时候美国的收入，差距是30年，太可怕了。在加上美联储降息周期还未看到，而特朗普的商业强势手段，只会持续降息，或许到2021年下一任总统上任会出现更好的结果，即使是连任也是有降的可能。</p>
<p>所以说目前的股市即使涨也不会涨太久或者说是很多，而对于此种行情，或许买板块是一个选择，比如5G、人工智能、半导体、新材料、电池技术、区块链技术等相关概念股票。</p>
<p>股市飞起，房价不跌反涨，足以说明即使4-10线城市房价跌出翔，而1、2、3线城市房价也不会跌太多，刚需太多，旱的旱死涝的涝死。北上广深人在不断较少，纷纷回归故乡到2-3线城市，而这个原因或许是边际成本的增加，让互联网巨头不得不布局2-3线城市，减低开发和人员成本，同时刺激国内小城市经济，带动了商业和地产，同时增加了地方财政收入，真是一举多得。</p>
<h3 id="面对股市、房地产、虚拟货币，我们应该怎样选择？"><a href="#面对股市、房地产、虚拟货币，我们应该怎样选择？" class="headerlink" title="面对股市、房地产、虚拟货币，我们应该怎样选择？"></a>面对股市、房地产、虚拟货币，我们应该怎样选择？</h3><p><img src="https://cdn.bsatoshi.com/2019/02/26/15511829551056.jpg" alt="2019投资风向标"></p>
<ul>
<li>股市20年，房地产40年，而对于投资回报可以说都是百倍、千倍的利润，但是刚刚发展10多年的数字货币却有万倍利益，对于投机者和新兴事物感兴趣的人或许这是一个机会，而错过的则是大多数人，对于13亿国内人口红利来说，数字货币才几千万而已，而区块链技术则是更小的范围，互联网时代成就了BATTMD等巨头公司，那对于区块链技术或许将会带来下一个千亿的巨头，而千禧一代的我们没赶上改革开放、错过了房地产、那么数字币和区块链技术或许是一个新的机会，数字支付是未来的趋势，中国央行已经全球首个法定数字货币测试运行，纳斯达克今日宣布上线比特币指数BLX和以太坊指数ELX，摩根大通推出摩根币，全球无论是资本市场还是zf都在布局数字支付，因此数字货币在未来还有更大的市场。</li>
</ul>
<ul>
<li><p>对于大多数中产，或许买了车或房之后就不再有什么资产，然而有更多的人可能连投资都不懂，那么钱只会存放在银行，很多南方人认为，钱在银行就是在贬值，或许这就是认知不同，而对于钱生钱很多人还是走稳妥路线，不买股票、不炒币。可能08、15年股灾让很多新认识到股票的人都以为这是骗人的，根本不可能盈利。投机的人吓跑了，胆小的人不敢投资，国内股市20年仍然是低迷时期，都说股市对标经济，那么这样看来经济是真的很差。</p>
</li>
<li><p>作为一个会理财的人，不能把鸡蛋放到一个篮子里，因此投资则需要多元化，曾经说过43221配置资产，如果你是激进的投资者那么把4投到风险大的里面，如果你是稳健型那么把4投到稳定收益的里面。</p>
</li>
<li><p>会理财、会赚钱，不拿死工资，唯一的办法就是开辟自己的第二职业，无论是写作还是视频制作，或者是糕点师等职业，总之你需要在工作之外还有一个感兴趣的事，或许这份投资会得到意想不到的收益。偏执狂不止是偏执，也是成功的一部分。</p>
</li>
</ul>
<p>Notice：</p>
<p>1.数字货币目前买币只买比特币和以太坊<br>2.股票只买概念股（5G、半导体、新材料、环境治理等）<br>3.房地产买2-3线城市，或新一线城市（杭州、南京、成都、苏州、合肥），在就是粤港湾地区肇庆或许是不错的选择<br>4.多读书提高认知，发现新的投资</p>
<ul>
<li><p>风险警示：币聪所有文章都不构成投资推荐，仅代表个人观点，如有异议请联系官方，投资有风险，投资应该考虑个人风险承受能力，建议对项目进行深入考察，慎重做好自己的投资决策。</p>
</li>
<li><p>币聪（比特B小白）詹强威：火B资讯签约作者、金色财经、千克、今日头条、企鹅号、加密圈、32know、支点、币乎等平台专栏作者</p>
</li>
</ul>
<p>推荐文章：</p>
<p><a href="https://www.btxiaobai.com/coinbase-1" target="_blank" rel="external">币聪看点：币圈独角兽，coinbase上架的币才是值得抄底的币吗？</a></p>
<p><a href="https://www.btxiaobai.com/bsatoshi-know-hodl" target="_blank" rel="external">币聪：提升自己的边界和认知，在加上坚持，或许这样的你才会成功</a></p>
<p><a href="https://www.btxiaobai.com/ada0035ada2019" target="_blank" rel="external">币聪行情：卡尔达诺ADA支撑位0.035美元还能撑多久，ADA会在2019年创下新的历史新高吗？</a></p>
<p><a href="https://www.btxiaobai.com/nanoblock-latticenano" target="_blank" rel="external">币聪百科：什么是Nano，Block-Lattice系统是否可以改变Nano低迷走势</a></p>
<p><a href="https://www.btxiaobai.com/20182" target="_blank" rel="external">币聪科技：尽管有多头熊市，比特币交易量在2018年超过2万亿美元</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;城市安放不了躯体&lt;/p&gt;
&lt;p&gt;故乡安放不了灵魂&lt;/p&gt;
&lt;p&gt;大家好，我是币聪（比特B小白）–詹强威&lt;/p&gt;
&lt;p&gt;每天码字的非专业程序员，每晚不定点（21:50）为你罗列B圈那些事&lt;/p&gt;
&lt;p&gt;认真写作第 18 天 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://
    
    </summary>
    
      <category term="区块链" scheme="http://idiot6.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="blockchain" scheme="http://idiot6.com/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>币聪百科系列文章之：为什么说币圈更需要增长黑客</title>
    <link href="http://idiot6.com/2019/02/13/grow_hacker/"/>
    <id>http://idiot6.com/2019/02/13/grow_hacker/</id>
    <published>2019-02-13T11:22:27.000Z</published>
    <updated>2019-04-10T11:30:59.868Z</updated>
    
    <content type="html"><![CDATA[<p>城市安放不了躯体</p>
<p>故乡安放不了灵魂</p>
<p>大家好，我是币聪（比特B小白）–詹强威</p>
<p>每天码字的非专业程序员，每晚21点50为你罗列B圈那些事</p>
<p>认真写作第 12 天 </p>
<p><img src="https://cdn.bsatoshi.com/2018/12/05/15422863789126.jpg" alt="币安增长黑客"></p>
<p>增长黑客，Growth Hacker是市场营销、产品研发、数据分析三个角色的聚合。Growth Hacker（增长黑客）这一群体将增长作为唯一的目标，他们以最快的方法、最低的成本、最高效的手段获取大量的增长。（来源：growingio）</p>
<p>增长黑客们试图用更聪明的方式解答产品的以增长的奥秘，并使之成为助力产品增长的长效机制。他们通常采用的手段包括A/B测试、搜索引擎优化、电子邮件召回、病毒营销、数据分析、用户画像等，而页面加载速度、注册转化率、E-mail到达水平、病毒因子这些指标成为他们日常关注的对象。</p>
<p><img src="https://cdn.bsatoshi.com/2018/12/05/15440152059752.jpg" alt="币安增长黑客"></p>
<p>换句话说，这是一群以数据驱动营销、以市场指导产品，通过技术化手段贯彻增长目标的人。他们通常既了解技术，又深谙用户心理，擅长发挥创意、绕过限制，通过低成本的手段解决初创公司产品早期的增长问题。在外行人眼里，他们就像是极客、发明家和广告狂人的混合体。再通俗一点形容，他们的职责接近与专门为初创公司设立的市场推广部门，因为很少有用于营销的大笔经费，所以更多的注意力聚焦在产品策略本身带来的自发增长上。</p>
<p>作为企业发展的助推者，增长黑客必须真正懂得产品的核心价值，能用最简单的语言描述这个产品是什么、解决什么问题，在此基础上清晰定位有关增长的问题，并寻求解答。（摘自：增长黑客–范冰）</p>
<p>很久之前国外已经把增长黑客当一门职业，比如著名的营销事件：Dropbox 通过 “推荐好友可以获取额外 500M 存储空间” 的病毒营销方式，实现了新用户每年 500% 增长的奇迹。LinkedIn 通过搜索引擎优化、邮件邀请搭建完善的运营机制，激活了了全球 4 亿活跃的职场人士。Slack 作为一款云端协作工具，提供大量免费功能和付费功能。随着越来越多用户使用 Slack ，其营业收入每 11 天就增加 100W 美元。增长黑客一书中提到了很多的案例，其实无外乎是市场营销、产品研发、数据分析这三个点出发，一个好的产品少不了营销，一个好的产品背后更少不了一个厉害的产品研发团队，而数据分析最为最后，则是在好的产品和研发支持的情况下，让懂数据的人留住这些曾经使用过的用户，以此实现增长。</p>
<p>这里我们以币安为例说明一下，增长黑客到底在币圈有多重要。</p>
<p><img src="https://cdn.bsatoshi.com/2018/12/05/15440153381521.jpg" alt="币安增长黑客"></p>
<p>首先币安交易所诞生与去年，也就是94之后，国内禁止了法币交易，因此在这个天时地利人和的情况下，币安被呈现在公众的眼前，而当市场低迷、政策打压的情况下，很多持币用户不知去哪里交易，其实还是有很多人不知道国外交易所的，毕竟去年币圈刚刚有点热度，就被一棒子打下去了，因此此时的币安得到了大量的用户，短短几个月冲击到了交易所排行全球第一，而用户也是达到了几百万，波场上线交易排行送币、交易排行第一送车等等活动，让币安达到了一个高度，圈走了币圈大量的用户。</p>
<p>有人说：“习惯是最可怕的一件事，因为习惯了就不想改变了。”，其实这句话是很对的，大多数人始终喜欢待在舒适区，而习惯使用一款软件也可以称为一个舒适区，也就是所谓的习惯，比如微信从2012推出以来，用户达到了10亿以上，而中国也不过14亿多人，基本人人都是微信对的时代，有人说微信是一种生活，那生活也是够冰冷的。</p>
<p>跑偏了，还是回到币安这个话题，交易所在诞生之后，以优质的产品体验和营销让币安至今都留存了大量的优质币圈用户，而同时也得到了口碑，这就是自然增长的一种，只是增长黑客的冰山一角，用户口碑、用户体验使其口口相传，以此实现增长更多优质用户。币安以用户体验和UI让更多的用户养成了习惯，如果此时用户看到另一家交易所，体验不好而又没什么多大利益可图，那么这个用户肯定是不会流失的，这就是用户体验带来的好处，同时此人也可能安利身边的朋友去使用币安。</p>
<p>今年的一个梗，都8102年了用户体验还那么差，会有人用吗，确实现在人活在舒适区，更活在体验区，如果一件产品体验不好，那么就是免费也可能不会有人使用，而优质的软件付费则仍然有人使用，这就是产品的重要性。</p>
<p>谈完产品，我们来看一下数据分析，数据分析，顾名思义就是大数据，曾经看到另一个说法叫做在线数据，个人感觉这个词更适合，数据不是只有大才好，不是活的根本都是垃圾，买量的时代，谁还相信大数据，而在线数据也可能是AI，近年来，人工智能的发展让机器人这个行业开始活起来了，而作为数据分析又该如何判定谁才是活的数据呢？</p>
<p><img src="https://cdn.bsatoshi.com/2018/12/05/15440143665078.jpg" alt="币安增长黑客"></p>
<p>币安作为交易所，其实无非就是看交易量、看用户交易活跃度、看用户购买的币种、看用户的存款大小、看用户的交易频率等方面以此判定此用户是否是一个机器人或者是一个不活跃用户，作为一个增长黑客，可不止只看用户的活跃行为，更应该去拉新、留存，比如SEO、ASO、社交软件、A/B测试、邮件找回等方面，目前正处于社交媒体时代，作为交易所也应该让自己的媒体活跃起来，目前币安社交媒体有TG、FB、推特、reddit、微博、medium、steemit、ins、youtube这些软件，可以说已经很优秀了，目前大多数交易所并没有这些社交媒体在同步进行，可以说币安已经走在了前面。上图是社交媒体为币安带来的流量，从数据来看是特别大的，而对于营销也是节省了一大部分成本，这就是增长黑客的力量。</p>
<p><img src="https://cdn.bsatoshi.com/2018/12/05/15440143831472.jpg" alt="币安增长黑客"><br><img src="https://cdn.bsatoshi.com/2018/12/05/15440143978780.jpg" alt="币安增长黑客"></p>
<p>在看下上面这两张图，两张图都是用户去往币安的一个跳板，而图1是通过搜索引擎、图2是通过广告投放，通过关键字进入到币安的是广告的一倍还多，你还敢说SEO、ASO不重要吗？是不是有种多花了几个亿的感觉。</p>
<p>社交媒体时代，人人都需要一个媒介去推广自己、或者是推广企业，这样才会达到利润更大化，也可以节省成本，在产品稳定之后并且可以带来很多意想不到的结果，曾经看一帖子说，自家产品并没有做什么推广，只是在抖音发乐几个帖子，今天突然暴涨近10w用户，企业根本不知道发生了什么，却实现了用户自然增长，这就是增长黑客的魅力所在。</p>
<p>为什么说币圈更需要增长黑客？</p>
<p>第一：市场目前处于低迷期，而用户在不断流失，一个毫无用户体验的产品又怎么可以吸引到新用户留得住老用户。</p>
<p>第二：币圈目前市场不大，而作为老牌交易所、或者是媒体、钱包、第三方技术服务等其他业务线，都应该需要做好自己的产品和口碑，这样就可以在下次爆发之前赢取更多的机会和用户。</p>
<p>第三：有人说币安的成功有很大一部分原因是因为一姐的影响力，而作为一个KOL，确实是可以带动很多人，因此这句话或许是对的，也有人说，如果你可以拥有一千个忠实用户，你无论出什么产品，他们都心甘情愿去买，那你这辈子就不用愁了，还有一个例子就是波场的诞生，孙宇晨作为娱乐圈的人，也是带动了很大一部分韭菜进入到了币圈，所以说无论是那个行业，都需要增长黑客，都需要一个好的产品，这样才会走的更远。</p>
<ul>
<li><p>风险警示：币聪所有文章都不构成投资推荐，仅代表个人观点，如有意义请联系官方，投资有风险，投资应该考虑个人风险承受能力，建议对项目进行深入考察，慎重做好自己的投资决策。</p>
</li>
<li><p>币聪（比特B小白）詹强威：火B资讯签约作者、金色财经、千克、今日头条、企鹅号、加密圈、32know、支点、币乎等平台专栏作者</p>
</li>
</ul>
<p>微信扫码免费加入知识星球，学习区块链技术和炒币技巧。</p>
<p><img src="https://cdn.bsatoshi.com/2018/12/05/15436691931522.jpg" alt="币安增长黑客"></p>
<p>推荐文章：</p>
<p><a href="https://www.btxiaobai.com/bsatoshi-know-hodl" target="_blank" rel="external">币聪：提升自己的边界和认知，在加上坚持，或许这样的你才会成功</a></p>
<p><a href="https://www.btxiaobai.com/ada0035ada2019" target="_blank" rel="external">币聪行情：卡尔达诺ADA支撑位0.035美元还能撑多久，ADA会在2019年创下新的历史新高吗？</a></p>
<p><a href="https://www.btxiaobai.com/nanoblock-latticenano" target="_blank" rel="external">币聪百科：什么是Nano，Block-Lattice系统是否可以改变Nano低迷走势</a></p>
<p><a href="https://www.btxiaobai.com/20182" target="_blank" rel="external">币聪科技：尽管有多头熊市，比特币交易量在2018年超过2万亿美元</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;城市安放不了躯体&lt;/p&gt;
&lt;p&gt;故乡安放不了灵魂&lt;/p&gt;
&lt;p&gt;大家好，我是币聪（比特B小白）–詹强威&lt;/p&gt;
&lt;p&gt;每天码字的非专业程序员，每晚21点50为你罗列B圈那些事&lt;/p&gt;
&lt;p&gt;认真写作第 12 天 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.b
    
    </summary>
    
      <category term="区块链" scheme="http://idiot6.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="blockchain" scheme="http://idiot6.com/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>币聪：从互联网思维思考三大交易所为何唯独币安未推出期货合约交易对</title>
    <link href="http://idiot6.com/2019/01/13/blockchain_binance/"/>
    <id>http://idiot6.com/2019/01/13/blockchain_binance/</id>
    <published>2019-01-13T14:55:27.000Z</published>
    <updated>2019-04-10T11:30:59.868Z</updated>
    
    <content type="html"><![CDATA[<p>城市安放不了躯体</p>
<p>故乡安放不了灵魂</p>
<p>大家好，我是币聪（比特币小白）–詹强威</p>
<p>每天码字的非专业程序员，每晚21点50为你罗列B圈那些事</p>
<p><img src="https://cdn.bsatoshi.com/2018/11/16/15422863789126.jpg" alt="币安交易所"></p>
<p>期货，通常指期货合约，是由期货交易所统一制定的、规定在将来某一特定的时间和地点交割一定数量标的物的标准化合约。这个标的物，可以是某种商品，也可以是某个金融工具，还可以是某个金融指标。</p>
<p>最初的期货交易是从现货远期交易发展而来，最初的现货远期交易是双方口头承诺在某一时间交收一定数量的商品，后来随着交易范围的扩大，口头承诺逐渐被买卖契约代替。</p>
<p>1570年伦敦开设的世界第一家商品远期合同交易所–皇家交易所。</p>
<p>1985年芝加哥谷物交易所推出了一种被称为“期货合约”的标准化协议，取代原先沿用的远期合同。</p>
<p>最初的期货交易只是运用在传统金融市场，最著名的有芝加哥期货交易所，纽约商业交易所，纽约商品交易所等平台，金融行业发展很多年以来，期货也渐渐成熟，在数字币交易以来就已经有推出期货交易对，目前著名的有CME、bitmex、okex、火币网等交易所，对于期货交易可能很多韭菜是又恨又爱，作为投资者如果没有很专业的操作经验是不推荐进行期货交易的，因为风险高、套路多。</p>
<p>国内三大交易所首先推出期货交易的是okex，对于okex交易所，相信大多数人都有很深的印象，接连不断的维权、拔网线、提前交割期货，这些事已经屡见不鲜，对于期货交易很多人都想着一夜暴富，百倍杠杠就像老虎机，进去是出不来的，天真的投机者，期货并不是你想的那么简单。</p>
<p>对于后推出期货交易的火币，或许玩法都是差不多，看谁套路深，经过近两个月测试的火币期货在今天终于上线了，首先我们来看一下介绍：”火币合约是一种数字货币衍生产品。用户可以通过判断涨跌，选择买入做多或卖出做空合约来获取数字货币价格上涨/下降的收益。火币合约使用差价交割的模式，合约到期时，所有未平仓的仓位，按照指数价格最后一小时的算术平均价进行平仓，而不是进行实物交割。“</p>
<p><img src="https://cdn.bsatoshi.com/2018/11/16/15423726390012.jpg" alt="-w997"></p>
<p>上图可以看出，火币期货合约和其他交易所无多大差别，之前未推出hbdm站之前是在火币全球站交易，而相比较火币、okex、bitmex，火币期货则相对比较平或，不会有特别大的事故产生，也有可能是小编不知道的，不过拔网线这种事在国内已经不是第一次了，习惯就好。</p>
<p>说过了okex、火币，那么币安为何没有推出自己的期货交易呢？</p>
<p>最近互联网在腾讯马化腾知乎提问之后，瞬间刮起了一股“产业互联网”的大风，都说流量时代的互联网已经过去了，都开始布局线下、工业、零售、To B产业等，无论是什么样的社区或者企业，用户始终都会被慢慢流失掉，曾经牛逼一时的人人卖身给doNew，互联网寒冬真点又一次来了，而对于腾讯这样的超级大佬，面对布局肯定是多方位、多形态。产业互联网将是互联网的下半场，那么对于区块链或许流量红利才刚刚开始，因为炒币的人还太少、懂区块链的人还太少，腾讯是以产品（微信、王者、LOL、吃鸡）为王的企业，在牛逼产品的环境下腾讯创造了一个帝国，或许币圈的币安，也会创造一个属于cz的（法币）交易所帝国。</p>
<p><img src="https://cdn.bsatoshi.com/2018/11/16/15423749071994.jpg" alt=""></p>
<p>去年94之后，在国内交易所纷纷关停法币的情况下，币安推出了币币交易，走非人民币交易路线，趁势币安获取了第一个百万用户，而其他交易所肯定不会放弃这个机会，于是乎都纷纷推出了海外交易所，实行币币交易，那么对于这样的环境下，为何币安还是走出了属于自己的独特产品路线，首先来说就是用户体验问题，币安交易所在推出币币交易时技术已经相当成熟，多终端交易+友好页面ui让币安在多个交易所之间得到了很大的优势，出名要趁早的理念，用户已经习惯了一种平台，自然会有一定口碑因此币安用户的不断增长，让币安已经成为了业内交易所交易量第一的平台，3月份已经突破790万用户，而在这样的情况下，币安仍然没有推出期货，而是走了法币交易的道路。</p>
<p>据币安创始人CZ所说，币安将在十个市场推出新的法币交易所，其中包括乌干达、英属泽西岛、列支敦士登、马耳他和新加坡等。今年6月29日，币安上线其首个法币交易所Binance Uganda （币安乌干达）。赵长鹏在接受 Cointelegraph 专访时表示：「乌干达的情况非常有趣，只有 11% 的人口拥有银行账户。这既是一个挑战，也是一个机会。因此，比起推动银行账户的普及，推进对于数字货币的采用可能更为容易。这是一个有趣的实验——非洲是一个大市场，这就是我们在那里的原因。</p>
<p>市场有多大，流量就有多大，面对这样的数字货币市场，CZ说：“未来还有1000倍的空间”。</p>
<p>对于币安未推出法币交易所，小编认为可能有以下几点原因：</p>
<p>第一，对于期货交易不容易留住用户，比如用户A今天爆仓了20个ETH，那可能就会对交易所产生一定的抵触，而对于交易所口碑也会有一定的影响。</p>
<p>第二，币安交易所推出之时就是走币币交易，OTC都未推出，说明他们保留初心，不触碰法律红线，就像微信不推出微信手机一样，商业模式不一样，所走的路线也不同。</p>
<p>第三，期货比现货交易更专业，原本在这样的情况下数字货币交易的门槛已经很高，给小白用户说合约无非是对牛弹琴，这样只会失去用户。</p>
<p>面对如今的区块链产业，获取用户并留存用户或许是交易所应该做的，如果只榨取用户，那么对于没有新鲜血液的市场，无论是交易所还是媒体、钱包等平台可能都面临走向衰落的阶段，如今互联网寒冬，公司都在大幅裁员，区块链同样也不好过，期货有风险，且买且珍惜。</p>
<p>风险警示：币聪所有文章都不构成投资推荐，投资有风险，投资应该考虑个人风险承受能力，建议对项目进行深入考察，慎重做好自己的投资决策。</p>
<p>币聪（比特币小白）詹强威：火B资讯签约作者、金色财经、千克、今日头条、企鹅号、加密圈、32know、支点、币互等平台专栏作者</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;城市安放不了躯体&lt;/p&gt;
&lt;p&gt;故乡安放不了灵魂&lt;/p&gt;
&lt;p&gt;大家好，我是币聪（比特币小白）–詹强威&lt;/p&gt;
&lt;p&gt;每天码字的非专业程序员，每晚21点50为你罗列B圈那些事&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.bsatoshi.com/2018/11
    
    </summary>
    
      <category term="区块链" scheme="http://idiot6.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="blockchain" scheme="http://idiot6.com/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>提升自己的边界和认知，在加上坚持，或许这样的你才会成功</title>
    <link href="http://idiot6.com/2018/11/29/2018-blockchain-life/"/>
    <id>http://idiot6.com/2018/11/29/2018-blockchain-life/</id>
    <published>2018-11-29T10:10:27.000Z</published>
    <updated>2018-11-29T10:12:12.450Z</updated>
    
    <content type="html"><![CDATA[<p>城市安放不了躯体</p>
<p>故乡安放不了灵魂</p>
<p>大家好，我是币聪（比特B小白）–詹强威</p>
<p>每天码字的非专业程序员，每晚21点50为你罗列B圈那些事</p>
<p>认真写作第 7 天</p>
<p><img src="https://cdn.bsatoshi.com/2018/11/29/15422863789126.jpg" alt="认知和边界"></p>
<p>最近很喜欢两个词，一个是“边界”，另一个是“认知”。</p>
<p>边界，维基百科上亦称疆界，指用于划分不同政权所辖区域、领地的地理分界线，进而可标示该区域的范围。基本是针对城市与城市之间可以有一个界限，并以此划界，而对于边界，其实有更多的意义。</p>
<p>互联网上的边界，经济学上的边界，知识的边界，人文的边界等等，有很多都可以称之为边界，最近内容创业如火如荼，而自媒体、新媒体行业也是风生水起，让知识的边界迅速火了起来，其实知识的边界有着完全不同两种方式。</p>
<p>一边是茫然的追寻着无法穷尽的选择，面对五花八门的公开课、知识付费，却不知道自缺的到底是哪个，订阅了无数的付费内容、下载了N个app，最终坚持下去的却没有几个，就像喜欢买书的人不喜欢看书一样，喜欢收藏URL的人，却最后不会看…..</p>
<p>边界的另一边则是有着清晰目的的人。他们清楚的知道自己想要什么，自己想要追寻什么样的知识升华或者是生活感受，在消费内容的时候首先问自己的是「我的目的是什么？」「我看这个视频/文章/书对我有帮助吗？」这个时候无论是知识星球、得到、知乎live、喜马拉雅、经济学人.商论、谷歌，并不是每一个产品都适合你，适合你的必是你可以坚持下去的。</p>
<p><img src="https://cdn.bsatoshi.com/2018/11/29/15434848153034.jpg" alt="认知和边界"></p>
<p>说到边界，就不得不提“认知”，认知，据维基上说：“在心理学中是指通过形成概念、知觉、判断或想象等心理活动来获取知识的过程，即个体思维进行信息处理的心理功能。认知过程可以是自然的或人造的、有意识或无意识；因此，麻醉学、神经科学、心理学、哲学、系统学以及计算机科学在分析认知时，其分析的聚焦点以及脉络是不同的。”，认知是多方面的，一个幼儿园小孩子的认知是单纯的、一个中学生的认知是多面的、一个成年人的认知是多变的，因为人越大事越多，所看和所想自然也就不一样。</p>
<p>从边界上谈论认知，当一个人的认知达到一定高度，就不会在停留在一个单纯的问题上，比如：“一个卖早餐的人，每天在CBD10点左右卖豆浆和包子”，对于这句话，可能每个人都的认知都不一样，甲说：“不就一卖包子的有什么好研究的”，乙说：“一个卖包子的人都可以每天坚持来出摊，为何我缺坚持不下去每天锻炼身体、学习英语，这不科学”，丙说：“这家卖早餐的生意那么好，背后应该有一定的秘诀，可能是包子好吃，豆浆比较实在，老板人比较好（口碑好）”，三个人三个不同的观点，这就是关于认知的一点点见解，就像一千人眼里有一千个哈姆雷特一样，每个人都是独特的一份子。</p>
<p>在追寻成功的路上，总是要付出很多的，也许你想过放弃、也许你想过这样的坚持根本就是不值得的，其实任何一件事只要坚持久了，必定有所收获，而且是意想不到的收获，比如经常锻炼身体的人，可以无形中让身份保持的更好，经常看书的人可以和朋友有很多共同的话题谈论，经常看电影的人可以当一个著名的影评家，任何一件事在坚持的背后都付出了很多很多时间，可能之中被否定过，被别人嫌弃过，其实那又怎么样呢，人最主要的是开心。</p>
<p><img src="https://cdn.bsatoshi.com/2018/11/29/15434847625149.jpg" alt="认知和边界"></p>
<p>自去年运营自媒体号“比特币小白（今日头条）”已经一年多，今日头条粉丝突破20000，网站注册用户17000多人，百家号8400多人，微信公众号4900多人，twitter、企鹅号、网易号、支点、金色、币乎、火币咨询等平台加起来也有20000多人，可以说中间也是坎坎坷坷，对于一个码农（本人是服务端程序员），运营是零基础的，最初的时候没有点击量和推荐，就慢慢的坚持，慢慢的多了粉丝，有人看了，自己的付出得到了认可，心里其实挺开心的，突然有一天被扣分了，没有盈利的情况下，就不怎么想做下去了，于是换了一个新号继续写一些区块链相关的文章，也是陆陆续续的增长用户，有一天登陆之前的号看到有一个粉丝私信我，说：“最近怎么不发文章和快讯了”，突然有点感动，原来这里还有人在等待着我发文章，于是我在不盈利的情况下继续运营了之前的号，就这样坚持了半年多，最终获取了原创功能，收益竟然也恢复了，可能这就是坚持的效果吧。</p>
<p>去年两会期间，以数字币为代表的号被封了很多，其中我运营的“比特币小白”也被封了，其实挺伤心的，没有了渠道、没有了盈利，于是迅速注册了一个小号，开始继续发文章，涨粉可以说是真的慢，又后怕腾讯会分分钟在封号，于是搞起了一个小网站，也是同时运营，开始转化用户，可能是当时的认知不到位，只看到了当时的蝇头小利，并不懂社区运营和商务的我，网站至今也是发展缓慢，并没有什么大的起色，或许一个人能力不够的时候真的应该多读书，去补充自己的不足，但是错过了就是错过了，已经没有办法回到过去…</p>
<p>就算是过了一年，此时的我，其实还是迷茫的，不知道自己追寻的到底是什么，现在也是每天写写代码、写写文章，重新捡起了公众号：“币聪财经”开始运营，也开发了小程序、app（IOS正审核中）、WEB端，由于在文章的开头写了每天21点50发文，前天有个粉丝在群里突然问到，小白今天不发文了吗，我回了句正在考试，其实挺尴尬的，此时我的内心再次被感动了，原来依然有人在等着我那写的不怎么好的文章，人家说：“不能做到的事，真的不能轻易答应，现在的我或许真的明白了”，可能我也是那个不能坚持的人，说到没有做到，我不知道自己的坚持对不对，但是坚持下去的精神寄托总是要有的，应该静下来想一想，你的坚持可能会给别人带去一点微不足道的认知，或许那就是一个小小的成就，那怕在微不足道，起码我们努力过。</p>
<p><img src="https://cdn.bsatoshi.com/2018/11/29/15434846256852.jpg" alt="认知和边界"></p>
<p>距离19年还有一个月的时间，此时的我并没有坚持多少事，比如最近帮朋友每天写一点区块链方面点评，目前已经快两个月了，最近夜跑已经快50公里了，不过最近今天看到一个帖子说晨跑是会上瘾的，或许应该调整一下，让自己战胜晚起的恶习，还有就是已经用随手记记录了1208天，或许这就是坚持吧，虽然并没有得到什么太大的回报，希望未来的文章会对你有用，也希望这件事我可以一直做下去，哪怕是不盈利的，只当一个爱好，人生在世，总要找点事做！</p>
<p>边界、认知，一个可以赚钱的idea。</p>
<ul>
<li><p>风险警示：币聪所有文章都不构成投资推荐，仅代表个人观点，如有意义请联系官方，投资有风险，投资应该考虑个人风险承受能力，建议对项目进行深入考察，慎重做好自己的投资决策。</p>
</li>
<li><p>币聪（比特B小白）詹强威：火B资讯签约作者、金色财经、千克、今日头条、企鹅号、加密圈、32know、支点、币乎等平台专栏作者</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;城市安放不了躯体&lt;/p&gt;
&lt;p&gt;故乡安放不了灵魂&lt;/p&gt;
&lt;p&gt;大家好，我是币聪（比特B小白）–詹强威&lt;/p&gt;
&lt;p&gt;每天码字的非专业程序员，每晚21点50为你罗列B圈那些事&lt;/p&gt;
&lt;p&gt;认真写作第 7 天&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.bsa
    
    </summary>
    
      <category term="心の栄養" scheme="http://idiot6.com/categories/%E5%BF%83%E3%81%AE%E6%A0%84%E9%A4%8A/"/>
    
    
      <category term="blockchain" scheme="http://idiot6.com/tags/blockchain/"/>
    
      <category term="life" scheme="http://idiot6.com/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>我的2017年</title>
    <link href="http://idiot6.com/2018/01/12/2017end/"/>
    <id>http://idiot6.com/2018/01/12/2017end/</id>
    <published>2018-01-12T09:50:27.000Z</published>
    <updated>2018-01-12T09:58:53.196Z</updated>
    
    <content type="html"><![CDATA[<p>嗯，又一年，过的好快！回顾过去一年，工作依然那么枯燥，生活还是那么单调，可能人总需要一点追求，过去一年我学会了自媒体和区块链技术、陆陆续续也写了很少的技术文章，也看了很多闲书，而最重要的是我看到了区块链技术和数字货币，然后开始了学习之路！</p>
<h3 id="关于GITHUB："><a href="#关于GITHUB：" class="headerlink" title="关于GITHUB："></a>关于GITHUB：</h3><ul>
<li>GITHUB：<pre><code>1. 博客陆陆续续也更新了几篇，绝大多数时间都去写区块链像关技术，好累的一年；
2. last year
</code></pre></li>
</ul>
<p><img src="http://cdn.btxiaobai.com/article/2018/01/12/IniuPP2hQSejdU3yzYJ2mvJqlEBI1O0b4k1o2Amu.png" alt="github"></p>
<h3 id="关于工作："><a href="#关于工作：" class="headerlink" title="关于工作："></a>关于工作：</h3><ul>
<li>WORK：<ol>
<li>在盖娅司龄已经二年半了，单一的业务似乎已经厌倦了，路似乎已经到头，需要重新起航！</li>
<li>书看的也是越来越少，只是找到了自己感兴趣的方向，区块链在未来肯定有更大的前景。</li>
</ol>
</li>
</ul>
<h3 id="关于读书："><a href="#关于读书：" class="headerlink" title="关于读书："></a>关于读书：</h3><ul>
<li>READ：<ol>
<li>区块链量子财富观(韩锋)</li>
<li>一页纸商业计划（马克·范·艾克）</li>
<li>财富自由之路（李笑来）</li>
<li>区块链原理、设计与应用（杨保华，陈昌 ）</li>
<li>区块链核心算法解析</li>
<li>区块链开发指南</li>
<li>图解密码技术(结城浩)</li>
<li>IBM商业价值报告:区块链</li>
<li>区块链技术指南</li>
<li>区块链技术原理及底层架构</li>
</ol>
</li>
</ul>
<h3 id="关于生活："><a href="#关于生活：" class="headerlink" title="关于生活："></a>关于生活：</h3><ul>
<li>LIFE：<ol>
<li>装备升级Macbook Pro、Iphone X；</li>
<li>续费了vps、买了一些数字币相关域名；</li>
<li>三年的股票终于解套了；</li>
</ol>
</li>
</ul>
<h3 id="关于社交："><a href="#关于社交：" class="headerlink" title="关于社交："></a>关于社交：</h3><ul>
<li>CHAT：<ol>
<li>加了一群天南地北的网友，炒币我们是认真的。</li>
<li>好久没有进游戏了，深夜写文章和粉丝聊天；</li>
</ol>
</li>
</ul>
<h3 id="关于未来："><a href="#关于未来：" class="headerlink" title="关于未来："></a>关于未来：</h3><ul>
<li>FATURE：<ol>
<li>1月份办了港澳通行证，今年去趟日本、三亚、参加各种大佬的会，学习不同的理念和营销学；</li>
<li>在这个计划赶不上变化的人生，2018貌似不能随缘了，我需要加快脚步；</li>
<li>好像开家公司事真的好多啊，需要补财务知识、营销知识、管理知识、市场调查，瞬间感觉自己读书好少；</li>
<li>从零开始的人生，会更精彩，走别人没有走过的路，才能走的更远！</li>
<li>学好英语很重要，233333333333333</li>
</ol>
</li>
</ul>
<blockquote>
<p>By：梦遥奇缘 2018-01-12</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嗯，又一年，过的好快！回顾过去一年，工作依然那么枯燥，生活还是那么单调，可能人总需要一点追求，过去一年我学会了自媒体和区块链技术、陆陆续续也写了很少的技术文章，也看了很多闲书，而最重要的是我看到了区块链技术和数字货币，然后开始了学习之路！&lt;/p&gt;
&lt;h3 id=&quot;关于GIT
    
    </summary>
    
      <category term="心の栄養" scheme="http://idiot6.com/categories/%E5%BF%83%E3%81%AE%E6%A0%84%E9%A4%8A/"/>
    
    
      <category term="点滴记录" scheme="http://idiot6.com/tags/%E7%82%B9%E6%BB%B4%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>解决CFBundleIdentifier&quot;, Does Not Exist</title>
    <link href="http://idiot6.com/2017/10/29/react-ios-native-CFBundleIdentifier/"/>
    <id>http://idiot6.com/2017/10/29/react-ios-native-CFBundleIdentifier/</id>
    <published>2017-10-29T13:59:08.000Z</published>
    <updated>2017-10-29T14:00:10.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mac-下运行react-native-run-ios-报错-CFBundleIdentifier”-Does-Not-Exist"><a href="#mac-下运行react-native-run-ios-报错-CFBundleIdentifier”-Does-Not-Exist" class="headerlink" title="mac 下运行react-native run-ios 报错 CFBundleIdentifier”, Does Not Exist"></a>mac 下运行react-native run-ios 报错 CFBundleIdentifier”, Does Not Exist</h1><p>1.产生原因：/Users/你的用户名<code>/.rncache中boost_1_63_0.tar.gz，double-conversion-1.1.5.tar.gz，folly-2016.09.26.00.tar.gz，glog-0.3.4.tar.gz文件不完整。或者node_modules/react-native/third-party</code> 文件不完整。</p>
<ul>
<li>删除/user/你的用户名/.rncache目录下的<code>boost_1_63_0</code>，重新下载安装</li>
<li>打开命令行工具，在项目目录下输入<code>rm -rf node_modules &amp;&amp; rm -rf ~/.rncache &amp;&amp; yarn</code></li>
<li><code>npm install</code>  </li>
<li><code>react-native upgrade</code> </li>
<li>运行 <code>react-native run-ios</code></li>
</ul>
<ol>
<li><p><a href="https://github.com/facebook/react-native/issues/7308" target="_blank" rel="external">github解答</a> ，似乎大多数点赞的是路径问题，配置真是一大难题！</p>
</li>
<li><p>如果以上问题仍然不能解决，那么你可以重新删除，编译环境生成项目，然后使用梯子代理全局模式下<code>npm install</code>（或者使用yarn），全局模式下最新版<code>react-native</code>并未出现 <code>CFBundleIdentifier</code>问题。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      有时候的失去未必不是一件好事，只是人生中的过客，又何必在意那么多。失去了才会懂得珍惜吗？
    
    </summary>
    
      <category term="react" scheme="http://idiot6.com/categories/react/"/>
    
    
      <category term="git" scheme="http://idiot6.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git pull出现 composer.lock被锁定</title>
    <link href="http://idiot6.com/2017/10/29/git_composer_lock/"/>
    <id>http://idiot6.com/2017/10/29/git_composer_lock/</id>
    <published>2017-10-29T13:50:08.000Z</published>
    <updated>2017-10-29T14:00:10.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git-pull出现-composer-lock被锁定，即是当前文件不是最新"><a href="#git-pull出现-composer-lock被锁定，即是当前文件不是最新" class="headerlink" title="git pull出现 composer.lock被锁定，即是当前文件不是最新"></a>git pull出现 composer.lock被锁定，即是当前文件不是最新</h1><ol>
<li>git fetch origin</li>
<li>git reset –hard origin/master</li>
<li>git pull</li>
</ol>
<h1 id="Your-local-changes-to-the-following-files-would-be-overwritten-by-merge"><a href="#Your-local-changes-to-the-following-files-would-be-overwritten-by-merge" class="headerlink" title="Your local changes to the following files would be overwritten by merge"></a>Your local changes to the following files would be overwritten by merge</h1><pre><code class="PHP">error: Your local changes to the following files would be overwritten by merge:
<span class="keyword">protected</span>/config/main.php
Please, commit your changes <span class="keyword">or</span> stash them before you can merge.
</code></pre>
<ul>
<li><p>解决方法：</p>
<ul>
<li>如果希望保留生产服务器上所做的改动,仅仅并入新配置项, 处理方法如下:</li>
<li>git stash</li>
<li>git pull</li>
<li>git stash pop</li>
</ul>
</li>
<li><p>然后可以使用git diff -w +文件名 来确认代码自动合并的情况.</p>
</li>
<li><p>同样，你也可以使用上述方法直接以线上库为最新代码。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      有时候的失去未必不是一件好事，只是人生中的过客，又何必在意那么多。失去了才会懂得珍惜吗？
    
    </summary>
    
      <category term="PHP" scheme="http://idiot6.com/categories/PHP/"/>
    
    
      <category term="git" scheme="http://idiot6.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>站长百度百家号添加json_ld报错</title>
    <link href="http://idiot6.com/2017/09/22/baijiahao/"/>
    <id>http://idiot6.com/2017/09/22/baijiahao/</id>
    <published>2017-09-22T09:40:53.000Z</published>
    <updated>2017-09-22T09:33:53.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="添加canonical标签（必选）"><a href="#添加canonical标签（必选）" class="headerlink" title="添加canonical标签（必选）"></a>添加canonical标签（必选）</h2><p>1.<code>&lt;link rel=&quot;canonical&quot; href=&quot;http(s)://xxx&quot;/&gt;</code><br>2.要求href的内容为mip页或h5页对应的PC页地址；如果没有PC页，则填写当前页面地址。</p>
<h3 id="添加json-ld数据"><a href="#添加json-ld数据" class="headerlink" title="添加json_ld数据"></a>添加json_ld数据</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"application/ld+json"</span>&gt;</div><div class="line">&#123;</div><div class="line">    <span class="string">"@context"</span>:<span class="string">"https://zhanzhang.baidu.com/contexts/cambrian.jsonld"</span>,</div><div class="line">    <span class="string">"@id"</span>:<span class="string">"https://btxiaobai.com/coinbaseethltc.html"</span>,</div><div class="line">    <span class="string">"title"</span>:<span class="string">"币圈大佬coinbase新增ETH和LTC钱包存储"</span>,</div><div class="line">    <span class="string">"images"</span>:[</div><div class="line">        <span class="string">"https://cdn.btxiaobai.com/article/2017/09/21/3FjRPCI635TFPHViuAaGa8kqzr0RTWTgjdTClOiN.png"</span>,</div><div class="line">        <span class="string">"https://cdn.btxiaobai.com/article/2017/09/21/TZpJXC0I7rV9YkG8gkrw0T4LL3XysM87y6KB5ifs.png"</span>,</div><div class="line">        <span class="string">"https://cdn.btxiaobai.com/article/2017/09/20/mPUtYXFtBOz3N9M9bcGO1TIztbzJmDtHOSKqnchL.png"</span></div><div class="line">        ],</div><div class="line">    <span class="string">"description"</span>:<span class="string">"coinbase新增ETH和LTC钱包存储"</span>,</div><div class="line">    <span class="string">"pubDate"</span>:<span class="string">"2017-09-22T16:23:00"</span></div><div class="line">&#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p>1.注意所有数据之前不能有空格、换行等特殊字符、时间字段须加T、图片最多三张、id为当前网页url！</p>
<h3 id="添加官方号ID声明（H5页面必选）"><a href="#添加官方号ID声明（H5页面必选）" class="headerlink" title="添加官方号ID声明（H5页面必选）"></a>添加官方号ID声明（H5页面必选）</h3><ol>
<li>在页面标签前添加代码、appid为当前已添加到站长网站的appid</li>
<li><code>eg:&lt;script src=&quot;//msite.baidu.com/sdk/c.js?appid=123456789&quot;&gt;&lt;/script&gt;</code></li>
</ol>
<h3 id="添加关注功能代码（强烈推荐）或者是mip页面"><a href="#添加关注功能代码（强烈推荐）或者是mip页面" class="headerlink" title="添加关注功能代码（强烈推荐）或者是mip页面"></a>添加关注功能代码（强烈推荐）或者是mip页面</h3><p>1.吸顶bar <code>&lt;script&gt;cambrian.render(&#39;head&#39;)&lt;/script&gt;</code></p>
<h3 id="格式校验"><a href="#格式校验" class="headerlink" title="格式校验"></a>格式校验</h3><p>1.复制当前文章页url、粘贴到校验地址上。</p>
<p>2.右键查看当前网页源代码，粘贴到网页源码选项。</p>
<p>3.点击校验，如出现json_ld格式错误，请查看提示（绝大多数是格式问题）。</p>
<h3 id="数据提交"><a href="#数据提交" class="headerlink" title="数据提交"></a>数据提交</h3><p>1.脚本提交数据，用php取出当前网站url，push到百度</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$urls = <span class="keyword">array</span>(</div><div class="line">    <span class="string">'https://www.btxiaobai.com/eroscoin.html'</span>,</div><div class="line">    <span class="string">'https://www.btxiaobai.com/j-japan-bitecoin.html'</span>,</div><div class="line">);</div><div class="line">$api = <span class="string">'http://data.zz.baidu.com/urls?site=https://www.btxiaobai.com/&amp;token=此处为你站长的token&amp;type=realtime'</span>;</div><div class="line">$ch = curl_init();</div><div class="line">$options =  <span class="keyword">array</span>(</div><div class="line">    CURLOPT_URL =&gt; $api,</div><div class="line">    CURLOPT_POST =&gt; <span class="keyword">true</span>,</div><div class="line">    CURLOPT_RETURNTRANSFER =&gt; <span class="keyword">true</span>,</div><div class="line">    CURLOPT_POSTFIELDS =&gt; implode(<span class="string">"\n"</span>, $urls),</div><div class="line">    CURLOPT_HTTPHEADER =&gt; <span class="keyword">array</span>(<span class="string">'Content-Type: text/plain'</span>),</div><div class="line">);</div><div class="line">curl_setopt_array($ch, $options);</div><div class="line">$result = curl_exec($ch);</div><div class="line"><span class="keyword">echo</span> $result;</div></pre></td></tr></table></figure>
<p><img src="https://cdn.btxiaobai.com/article/2017/09/22/eHei4zYsn3vEI8yKdcPCNJdglY1vwwzYDS6ArCMQ.png" alt="返回结果"></p>
<h3 id="效果查看"><a href="#效果查看" class="headerlink" title="效果查看"></a>效果查看</h3><p><a href="https://btxiaobai.com" target="_blank" rel="external">比特币小白</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;添加canonical标签（必选）&quot;&gt;&lt;a href=&quot;#添加canonical标签（必选）&quot; class=&quot;headerlink&quot; title=&quot;添加canonical标签（必选）&quot;&gt;&lt;/a&gt;添加canonical标签（必选）&lt;/h2&gt;&lt;p&gt;1.&lt;code&gt;&amp;l
    
    </summary>
    
      <category term="php" scheme="http://idiot6.com/categories/php/"/>
    
    
      <category term="json_ld" scheme="http://idiot6.com/tags/json-ld/"/>
    
      <category term="canonical" scheme="http://idiot6.com/tags/canonical/"/>
    
  </entry>
  
  <entry>
    <title>经典抽奖算法</title>
    <link href="http://idiot6.com/2017/08/03/lottery_active/"/>
    <id>http://idiot6.com/2017/08/03/lottery_active/</id>
    <published>2017-08-03T10:59:27.000Z</published>
    <updated>2017-08-03T11:05:46.535Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义中奖概率数组"><a href="#定义中奖概率数组" class="headerlink" title="定义中奖概率数组"></a>定义中奖概率数组</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> $innerRate = <span class="keyword">array</span>(</div><div class="line"><span class="string">'1'</span> =&gt; <span class="number">1</span>,</div><div class="line"><span class="string">'2'</span> =&gt; <span class="number">200</span>,</div><div class="line"><span class="string">'3'</span> =&gt; <span class="number">500</span>,</div><div class="line"><span class="string">'4'</span> =&gt; <span class="number">100000</span>,</div><div class="line"><span class="string">'5'</span> =&gt; <span class="number">300000</span>,</div><div class="line"><span class="string">'6'</span> =&gt; <span class="number">1693000</span>,</div><div class="line">);</div></pre></td></tr></table></figure>
<h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>1.<code>$i = $this-&gt;getRand($this-&gt;innerRate)</code>;<br>2.根据返回的$i,处理当前返回逻辑，if和switch都可以。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>($i==<span class="number">1</span>)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">echo</span> <span class="string">"一等奖"</span>;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">	<span class="keyword">echo</span> <span class="string">"二等奖"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="基础函数"><a href="#基础函数" class="headerlink" title="基础函数"></a>基础函数</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">getRand</span><span class="params">($proArr)</span></span></div><div class="line">&#123;</div><div class="line">    $result = <span class="string">''</span>;</div><div class="line">    <span class="comment">// 概率数组的总概率精度</span></div><div class="line">    $proSum = array_sum($proArr);</div><div class="line">    <span class="comment">// 概率数组循环</span></div><div class="line">    <span class="keyword">foreach</span> ($proArr <span class="keyword">as</span> $key =&gt; $proCur) &#123;</div><div class="line">        $randNum = mt_rand(<span class="number">1</span>, $proSum); <span class="comment">// 抽取随机数</span></div><div class="line">        <span class="keyword">if</span> ($randNum &lt;= $proCur) &#123;</div><div class="line">            $result = $key; <span class="comment">// 得出结果</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            $proSum -= $proCur;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">unset</span>($proArr);</div><div class="line">    <span class="keyword">return</span> $result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义中奖概率数组&quot;&gt;&lt;a href=&quot;#定义中奖概率数组&quot; class=&quot;headerlink&quot; title=&quot;定义中奖概率数组&quot;&gt;&lt;/a&gt;定义中奖概率数组&lt;/h2&gt;&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
    
    </summary>
    
      <category term="PHP" scheme="http://idiot6.com/categories/PHP/"/>
    
    
      <category term="lottery" scheme="http://idiot6.com/tags/lottery/"/>
    
  </entry>
  
  <entry>
    <title>阿里云低配ECS NPM线上打包卡死解决办法</title>
    <link href="http://idiot6.com/2017/07/25/npm_run_pro_error/"/>
    <id>http://idiot6.com/2017/07/25/npm_run_pro_error/</id>
    <published>2017-07-25T15:45:27.000Z</published>
    <updated>2017-07-25T06:13:39.715Z</updated>
    
    <content type="html"><![CDATA[<p>1.<code>npm install</code> #没问题</p>
<p>2.<code>npm run production</code> 打包进行中，经历了三次，最多到65%，后来直接vps挂掉（cpu没满，可能是I/O瓶颈，用的是低配），重启然后加swap。</p>
<p>3.创建文件作为交换分区（相当于 Windows 的虚拟内存页面文件 3GB）：<code>dd if=/dev/zero of=/mnt/swap bs=1024 count=3194304</code> </p>
<p>4.设置交换分区文件：<code>mkswap /mnt/swap swapon /mnt/swap</code></p>
<p>5.加入挂载点：<code>echo &quot;/mnt/swap swap swap defaults 0 0&quot; &gt;&gt; /etc/fstab</code></p>
<p>6.挂载：<code>SWAP： mount -a</code></p>
<blockquote>
<p>By 这些年踩过的坑</p>
<blockquote>
<p>梦遥奇缘</p>
</blockquote>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.&lt;code&gt;npm install&lt;/code&gt; #没问题&lt;/p&gt;
&lt;p&gt;2.&lt;code&gt;npm run production&lt;/code&gt; 打包进行中，经历了三次，最多到65%，后来直接vps挂掉（cpu没满，可能是I/O瓶颈，用的是低配），重启然后加swap。&lt;/p
    
    </summary>
    
      <category term="PHP" scheme="http://idiot6.com/categories/PHP/"/>
    
    
      <category term="NPM" scheme="http://idiot6.com/tags/NPM/"/>
    
      <category term="swap" scheme="http://idiot6.com/tags/swap/"/>
    
  </entry>
  
</feed>
